# SPEC_INTERNAL_SERVICE_AUTH

**Status:** Accepted (addresses DECISION_172 Oracle “Must Implement #1”)  
**Owner:** Nexus  
**Audience:** Implementers  
**Last updated:** 2026-02-28

## 0) Purpose

Define **service-to-service authentication** for Web → Core internal calls on Railway.

Goals:
- Single public entry: Next.js (`web`)
- Core is internal-only but still authenticated (do not rely on network secrecy)
- Short-lived credentials with clear rotation procedure
- Correlation IDs and audit logging for failures

This spec is compatible with `SPEC_ENDPOINT_CONTRACT.md` and `SPEC_RAILWAY_ARCHITECTURE.md`.

---

## 1) Decision

Use **short-lived signed JWTs** for Web → Core requests.

- Web signs a JWT per request (or per short session) with a short expiry.
- Core validates JWT on every request.
- Core does not accept trusted headers without a valid JWT.

Fallback (MVP only):
- A rotating shared token (Bearer) MAY be used temporarily, but JWT is preferred.

---

## 2) JWT claims (required)

### 2.1 Required claims
- `iss`: `"web"`
- `aud`: `"core"`
- `sub`: web service identity (e.g., `"web-service"`) OR user id if you prefer user-bound tokens
- `iat`: issued-at (unix seconds)
- `exp`: expiry (unix seconds)
- `jti`: unique token id (uuid)

### 2.2 Optional but recommended
- `uid`: end-user id (for per-user rate limiting / attribution)
- `role`: `"admin" | "user"` (for authorization decisions inside core)
- `rid`: request id (for tracing)

### 2.3 TTL requirements
- `exp - iat` must be **5–15 minutes**.
- Reject tokens outside a clock skew window (± 60 seconds).

---

## 3) Key management and rotation

### 3.1 Key format
Use an HMAC key for MVP:
- Algorithm: `HS256`
- Env var in Web: `INTERNAL_JWT_SIGNING_KEYS` (JSON array)
- Env var in Core: `INTERNAL_JWT_VERIFY_KEYS` (JSON array)

Example:
```json
[
  {"kid":"k1","secret":"<random>","active":true},
  {"kid":"k0","secret":"<old-secret>","active":false}
]
```

### 3.2 Rotation strategy (dual-key)
- Web signs with the **active** key.
- Core accepts both active and previous keys during transition.
- Rotation procedure:
  1) Add new key to both Web and Core key sets (mark new key active in Web only after Core has it).
  2) Deploy Core.
  3) Deploy Web (starts signing with new key).
  4) Keep old key in Core for 24–72 hours for safety.
  5) Remove old key from both.

---

## 4) Request headers (required)

Web must include:
- `Authorization: Bearer <jwt>`
- `X-Request-Id: <uuid>` (generated by Web)
- Optionally:
  - `X-User-Id`
  - `X-User-Role`

Core must:
- validate JWT first
- treat `X-User-*` headers as advisory unless included in JWT claims

---

## 5) Authorization policy inside Core (minimum)

Core endpoints are internal-only and still must enforce:
- Token required, valid, not expired
- `aud == "core"`
- `iss == "web"`

Role-gated routes:
- indexing/reindex endpoints must require `role=admin` claim

---

## 6) Logging and audit

### 6.1 Core logs (minimum)
For every request:
- request id
- endpoint
- token validation result (success/fail)
- failure reason (expired, bad signature, wrong aud/iss)

### 6.2 Audit log (Web)
Web writes to `audit_log` for:
- admin actions
- auth failures to Core (rate-limited to avoid log spam)

---

## 7) Replay resistance (MVP pragmatic)
For MVP:
- `jti` is logged and can be inspected
- do not store every `jti` server-side unless needed

If you observe replay attempts:
- add a `jwt_jti` collection with TTL index (15 minutes)
- reject reused `jti` values

---

## 8) Verification checklist
- [ ] Core rejects requests without Authorization header
- [ ] Core rejects tokens with wrong `aud` or `iss`
- [ ] Core rejects expired tokens
- [ ] Key rotation supports dual-key overlap
- [ ] Auth failures are logged with request ids
