# Designer Deep-Dive Consultation: FORGE-001

**Decision**: FORGE-001 Directory Architecture Standardization  
**Date**: 2026-02-18 21:15:00  
**Requested By**: Strategist  
**Consultation Type**: Detailed Implementation Architecture  
**Target**: Address Oracle gaps to achieve 90%+ approval  

---

## Oracle Feedback Summary (68% Approval)

Oracle identified critical gaps preventing higher approval:

1. **No automated rebuild strategy for `.index/`**
   - Risk: Index corruption = single point of failure
   - Required: Deterministic rebuild command

2. **No ID sequencing control during migration**
   - Risk: Duplicate IDs during concurrent work
   - Required: Lock mechanism or single allocator

3. **Validation gates need staging**
   - Risk: Hard validation stalls active work
   - Required: Warning → Hard fail progression

4. **Reference breakage risk**
   - Risk: Broken links during path changes
   - Required: Path alias registry

**Target**: Address all blockers to reach 90%+ Oracle approval

---

## Deep-Dive Questions for Designer

### 1. Automated Index Rebuild System (Critical)

**Q1.1**: Design a complete `rebuild-index` system. What are the specific components?

**Requirements**:
- Scan all directories recursively
- Extract metadata from file headers
- Validate cross-references
- Generate all `.json` index files
- Handle errors gracefully
- Be idempotent (safe to run multiple times)

**Q1.2**: What triggers the rebuild?
- On every file write? (performance cost)
- On-demand only? (stale index risk)
- Scheduled? (nightly rebuild)
- Git hook? (pre-commit validation)

**Q1.3**: Recovery procedure if index is corrupted?
- How to detect corruption?
- Automated vs manual recovery?
- Rollback strategy?

### 2. ID Sequencing and Allocation System (Critical)

**Q2.1**: Design an ID allocation system that prevents duplicates during migration

**Options**:
- File-based lock (simple, but single-writer)
- Central allocator service (complex)
- UUID-based (no sequencing, but unique)
- Timestamp-based (unique, sortable)

**Q2.2**: How do we handle concurrent ID allocation?
- Strategist only allocates during migration?
- Or build simple atomic increment mechanism?

**Q2.3**: ID reservation system for bulk operations?
- Reserve block of IDs for WindSurf batch?
- Pre-assign ranges to different agents?

### 3. Path Alias and Redirect System (Critical)

**Q3.1**: Design `.index/redirects.json` schema

**Requirements**:
- Map old paths to new paths
- Support wildcard patterns?
- Version tracking (when redirect added)
- Expiration (when redirect removed)

**Q3.2**: How do agents use redirects?
- Check redirects on every read? (performance)
- Or maintain in-memory cache? (staleness)
- Or resolve once during migration?

**Q3.3**: Redirect validation?
- Verify target exists?
- Detect circular redirects?
- Alert on unused redirects?

### 4. Validation Pipeline Architecture (Critical)

**Q4.1**: Design staged validation system

**Stages**:
- Stage 0: No validation (migration)
- Stage 1: Warning only (log issues)
- Stage 2: Soft enforcement (allow override)
- Stage 3: Hard enforcement (block writes)

**Q4.2**: Validation rules as code or config?
- Hard-coded in scripts? (fast, inflexible)
- JSON schema files? (flexible, slower)
- Hybrid approach?

**Q4.3**: How to bypass validation in emergencies?
- Override flag?
- Admin override?
- Audit trail required?

### 5. Granular Decision Making Workflow (Enhancement)

**Q5.1**: Current decisions are monolithic. Design micro-decision workflow for:
- Individual feature decisions
- Component-level architecture
- Implementation approach selection
- Testing strategy decisions
- Deployment method decisions

**Q5.2**: Decision hierarchy:
```
Strategic Decision (FORGE-001)
├── Technical Decision (TECH-XXX)
│   ├── Component Decision (COMP-XXX)
│   │   ├── Implementation Decision (IMPL-XXX)
│   │   └── Testing Decision (TEST-XXX)
```

**Q5.3**: When to use granular vs monolithic?
- File count threshold?
- Complexity threshold?
- Time estimate threshold?

### 6. Decision Template Enhancement (Critical)

**Q6.1**: Expand DECISION-TEMPLATE.md with sections for:
- **Requirements** (functional, non-functional)
- **Architecture** (diagrams, components)
- **Implementation** (phases, tasks)
- **Testing** (test plan, validation)
- **Deployment** (rollout strategy, rollback)
- **Operations** (monitoring, maintenance)
- **Improvement** (metrics, feedback loops)

**Q6.2**: Each section should have:
- Required vs optional indicators
- Example content
- Validation rules
- Approval gates

### 7. Testing Strategy for Decisions (Critical)

**Q7.1**: How do we test that a Decision was implemented correctly?

**Test Types**:
- Structure tests (directories exist?)
- Content tests (required headers present?)
- Integration tests (cross-references valid?)
- Functional tests (workflows execute?)

**Q7.2**: Test automation?
- Pre-implementation validation?
- Post-implementation verification?
- Continuous monitoring?

**Q7.3**: Test data/fixtures?
- Mock decisions for testing?
- Sandbox environment?
- Dry-run mode?

### 8. Deployment and Rollback Plan (Critical)

**Q8.1**: Deployment phases with specific criteria

**Phase Gates**:
- What signals "proceed to Phase 2"?
- What triggers rollback?
- Who decides go/no-go?

**Q8.2**: Rollback procedure:
- How quickly can we revert?
- What data is lost on rollback?
- Communication plan?

**Q8.3**: Feature flags or configuration?
- Enable/disable validation?
- Toggle old/new path resolution?
- A/B testing capability?

### 9. Monitoring and Observability (Enhancement)

**Q9.1**: What metrics should we track?

**Suggested Metrics**:
- Decision creation rate
- Consultation request/response time
- Action completion rate
- File placement errors
- Index consistency
- Agent confusion incidents

**Q9.2**: Dashboard design?
- Health indicators
- Trending graphs
- Alert thresholds

**Q9.3**: Automated alerts?
- Index corruption detected
- Validation failure spike
- Migration stuck
- Approval rating dropping

### 10. Continuous Improvement Loop (Critical)

**Q10.1**: Design the improvement feedback mechanism:

```
Execute Decision
    ↓
Measure outcomes
    ↓
Identify gaps
    ↓
Create improvement Decision
    ↓
Consult Oracle/Designer
    ↓
Implement improvement
    ↓
Repeat
```

**Q10.2**: Improvement Decision template:
- Trigger conditions
- Success metrics
- Rollback criteria
- A/B comparison approach

**Q10.3**: How to prevent "decision fatigue"?
- Auto-approve minor improvements?
- Batch related improvements?
- Threshold for requiring full consultation?

---

## Deliverable Requirements

Designer must provide:

1. **Complete system design** for each critical component
2. **Code examples** where applicable (PowerShell/C#)
3. **Decision workflow diagrams**
4. **Template specifications**
5. **Testing strategy document**
6. **Deployment runbook**
7. **Monitoring dashboard specification**

---

## Target Outcome

After this consultation, FORGE-001 should have:
- ✅ Automated index rebuild system design
- ✅ ID allocation mechanism specification
- ✅ Path alias system design
- ✅ Staged validation pipeline
- ✅ Granular decision workflow
- ✅ Enhanced templates
- ✅ Complete testing strategy
- ✅ Deployment and rollback procedures
- ✅ Monitoring and observability plan
- ✅ Continuous improvement loop

**Goal**: 90%+ Oracle approval rating

---

**Designer**: Please provide comprehensive design for each section above. Use code examples, diagrams (ASCII art acceptable), and concrete specifications. Address all Oracle concerns with detailed solutions.

**Files to Update**:
- `consultations/designer/2026-02-18T21-15-00-FORGE-001-Deep-Dive.md` (this file)
- `decisions/active/FORGE-001-Directory-Architecture.md` (assimilate findings)
- Create additional specs in `context/briefs/` as needed

---

## Designer Response

**Aegis, Designer** — Comprehensive system architecture for FORGE-001

---

# PART 1: AUTOMATED INDEX REBUILD SYSTEM

## 1.1 System Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INDEX REBUILD SYSTEM                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐                 │
│   │   Scanner    │───▶│   Parser     │───▶│  Validator   │                 │
│   │   Module     │    │   Module     │    │   Module     │                 │
│   └──────────────┘    └──────────────┘    └──────────────┘                 │
│          │                   │                   │                         │
│          ▼                   ▼                   ▼                         │
│   ┌─────────────────────────────────────────────────────────┐              │
│   │              INDEX STATE MANAGER                        │              │
│   │  ┌────────────┐  ┌────────────┐  ┌────────────────┐    │              │
│   │  │   File     │  │   JSON     │  │  Checkpoint    │    │              │
│   │  │  Scanner   │  │  Writer    │  │  Recovery      │    │              │
│   │  └────────────┘  └────────────┘  └────────────────┘    │              │
│   └─────────────────────────────────────────────────────────┘              │
│                              │                                             │
│                              ▼                                             │
│   ┌─────────────────────────────────────────────────────────┐              │
│   │              OUTPUT: .index/ Directory                   │              │
│   │  ├─ decisions.json   (catalog of all decisions)         │              │
│   │  ├─ consultations.json (catalog of all consultations)   │              │
│   │  ├─ actions.json     (catalog of all actions)           │              │
│   │  ├─ references.json  (cross-reference map)              │              │
│   │  ├─ aliases.json     (path alias registry)              │              │
│   │  └─ health.json      (system health status)             │              │
│   └─────────────────────────────────────────────────────────┘              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 1.2 PowerShell Implementation: `Rebuild-TacticsIndex.ps1`

```powershell
#requires -Version 7.0
#requires -Modules @{ ModuleName="Pester"; ModuleVersion="5.0" }

<#
.SYNOPSIS
    Rebuilds the TACTICS index from source files.
.DESCRIPTION
    Scans all decision, consultation, and action files, extracts metadata,
    validates cross-references, and regenerates the .index/ directory.
    This script is IDEMPOTENT and SAFE to run multiple times.
.PARAMETER RootPath
    Root path to T4CT1CS directory (default: $PSScriptRoot/..)
.PARAMETER DryRun
    Simulate rebuild without writing files
.PARAMETER Force
    Force rebuild even if corruption is detected
.PARAMETER CheckpointInterval
    Number of files processed between checkpoint saves (default: 10)
#>

[CmdletBinding(SupportsShouldProcess = $true)]
param(
    [string]$RootPath = (Join-Path $PSScriptRoot ".."),
    [switch]$DryRun,
    [switch]$Force,
    [int]$CheckpointInterval = 10
)

# Configuration
$Script:Config = @{
    IndexDir        = ".index"
    DecisionsDir    = "decisions"
    ConsultationsDir = "consultations"
    ActionsDir      = "actions"
    CheckpointsDir  = ".index/.checkpoints"
    BackupDir       = ".index/.backups"
    MetadataVersion = "1.0.0"
}

# Logging System
function Write-TacticsLog {
    param([string]$Level, [string]$Message, [string]$Component)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
    $logEntry = "[$timestamp] [$Component] [$Level] $Message"
    Write-Host $logEntry -ForegroundColor $(switch($Level) {
        "ERROR" { "Red" }
        "WARN"  { "Yellow" }
        "INFO"  { "Cyan" }
        "DEBUG" { "Gray" }
        default { "White" }
    })
    # Also write to log file
    Add-Content -Path "$RootPath/.index/rebuild.log" -Value $logEntry -ErrorAction SilentlyContinue
}

# Error Classification
enum RebuildErrorSeverity {
    CRITICAL    # Stop rebuild, manual intervention required
    WARNING     # Log warning, continue with degraded functionality
    INFO        # Informational only
}

class RebuildError {
    [string]$FilePath
    [string]$ErrorType
    [string]$Message
    [RebuildErrorSeverity]$Severity
    [string]$SuggestedFix
    [datetime]$Timestamp

    RebuildError($path, $type, $msg, $sev, $fix) {
        $this.FilePath = $path
        $this.ErrorType = $type
        $this.Message = $msg
        $this.Severity = $sev
        $this.SuggestedFix = $fix
        $this.Timestamp = Get-Date
    }
}

# Global Error Collection
$Script:RebuildErrors = [System.Collections.ArrayList]::new()

# Checkpoint System
function Save-Checkpoint {
    param([hashtable]$State, [int]$FileNumber)
    $checkpointPath = Join-Path $RootPath $Script:Config.CheckpointsDir "checkpoint_$FileNumber.json"
    $State | ConvertTo-Json -Depth 20 | Set-Content -Path $checkpointPath
    Write-TacticsLog -Level "DEBUG" -Message "Checkpoint saved: $FileNumber" -Component "Checkpoint"
}

function Restore-Checkpoint {
    param([int]$FileNumber)
    $checkpointPath = Join-Path $RootPath $Script:Config.CheckpointsDir "checkpoint_$FileNumber.json"
    if (Test-Path $checkpointPath) {
        return Get-Content $checkpointPath | ConvertFrom-Json -AsHashtable
    }
    return $null
}

# File Header Parser
function Get-TacticsFileMetadata {
    param([string]$FilePath)
    
    $content = Get-Content -Path $FilePath -Raw -Encoding UTF8
    $metadata = @{}
    
    # Extract YAML frontmatter (--- ... ---)
    if ($content -match "^---\s*\r?\n(.*?)\r?\n---") {
        $frontmatter = $matches[1]
        
        # Parse key-value pairs
        $frontmatter -split "`r?\n" | ForEach-Object {
            if ($_ -match "^(\w+):\s*(.+)$") {
                $key = $matches[1].Trim()
                $value = $matches[2].Trim()
                $metadata[$key] = $value
            }
        }
    }
    
    # Extract Decision ID from filename or content
    if ($FilePath -match "([A-Z]+-\d+)") {
        $metadata['ExtractedId'] = $matches[1]
    }
    
    # Extract cross-references from body
    $references = [System.Collections.ArrayList]::new()
    $refPattern = '\[([^\]]+)\]\(([^)]+)\)|`([A-Z]+-\d+)`|#([A-Z]+-\d+)'
    [regex]::Matches($content, $refPattern) | ForEach-Object {
        if ($_.Groups[3].Success) { $references.Add($_.Groups[3].Value) | Out-Null }
        if ($_.Groups[4].Success) { $references.Add($_.Groups[4].Value) | Out-Null }
        if ($_.Groups[2].Success -and $_.Groups[2].Value -match "[A-Z]+-\d+") {
            $references.Add($matches[0]) | Out-Null
        }
    }
    $metadata['References'] = $references
    
    # Calculate hash for integrity
    $hash = [System.Security.Cryptography.SHA256]::Create()
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($content)
    $metadata['ContentHash'] = [Convert]::ToBase64String($hash.ComputeHash($bytes))
    $metadata['LastModified'] = (Get-Item $FilePath).LastWriteTimeUtc.ToString("o")
    $metadata['FileSize'] = (Get-Item $FilePath).Length
    
    return $metadata
}

# Validation Functions
function Test-DecisionIntegrity {
    param([hashtable]$Metadata, [string]$FilePath)
    $errors = [System.Collections.ArrayList]::new()
    
    # Required fields check
    $required = @('DecisionId', 'Status', 'Created', 'Author')
    foreach ($field in $required) {
        if (-not $Metadata.ContainsKey($field)) {
            $errors.Add([RebuildError]::new(
                $FilePath,
                "MissingRequiredField",
                "Missing required field: $field",
                [RebuildErrorSeverity]::WARNING,
                "Add '$field: value' to frontmatter"
            )) | Out-Null
        }
    }
    
    # ID consistency check
    if ($Metadata.ContainsKey('DecisionId') -and 
        $Metadata.ContainsKey('ExtractedId') -and
        $Metadata['DecisionId'] -ne $Metadata['ExtractedId']) {
        $errors.Add([RebuildError]::new(
            $FilePath,
            "IdMismatch",
            "DecisionId ($($Metadata['DecisionId'])) doesn't match filename ($($Metadata['ExtractedId']))",
            [RebuildErrorSeverity]::WARNING,
            "Rename file or update DecisionId in frontmatter"
        )) | Out-Null
    }
    
    # Date format validation
    if ($Metadata.ContainsKey('Created')) {
        try {
            [datetime]::Parse($Metadata['Created'])
        } catch {
            $errors.Add([RebuildError]::new(
                $FilePath,
                "InvalidDateFormat",
                "Created date '$($Metadata['Created'])' is not a valid date",
                [RebuildErrorSeverity]::WARNING,
                "Use ISO 8601 format: 2026-02-18T21:15:00"
            )) | Out-Null
        }
    }
    
    return $errors
}

# Main Rebuild Function
function Start-IndexRebuild {
    Write-TacticsLog -Level "INFO" -Message "=== TACTICS INDEX REBUILD STARTED ===" -Component "Rebuild"
    
    # Ensure directories exist
    $indexDir = Join-Path $RootPath $Script:Config.IndexDir
    $checkpointDir = Join-Path $RootPath $Script:Config.CheckpointsDir
    $backupDir = Join-Path $RootPath $Script:Config.BackupDir
    
    if (-not $DryRun) {
        @($indexDir, $checkpointDir, $backupDir) | ForEach-Object {
            New-Item -ItemType Directory -Force -Path $_ | Out-Null
        }
        
        # Backup existing index
        if (Test-Path "$indexDir/decisions.json") {
            $backupName = "backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
            Copy-Item -Path $indexDir -Destination "$backupDir/$backupName" -Recurse -Force
            Write-TacticsLog -Level "INFO" -Message "Backed up existing index to $backupName" -Component "Backup"
        }
    }
    
    # Scan all directories
    $allFiles = @()
    $scanPaths = @(
        @{ Path = Join-Path $RootPath $Script:Config.DecisionsDir; Type = 'decision' },
        @{ Path = Join-Path $RootPath $Script:Config.ConsultationsDir; Type = 'consultation' },
        @{ Path = Join-Path $RootPath $Script:Config.ActionsDir; Type = 'action' }
    )
    
    foreach ($scan in $scanPaths) {
        if (Test-Path $scan.Path) {
            $files = Get-ChildItem -Path $scan.Path -Filter "*.md" -Recurse
            $files | ForEach-Object {
                $allFiles += @{
                    Path = $_.FullName
                    RelativePath = $_.FullName.Substring($RootPath.Length + 1)
                    Type = $scan.Type
                    Category = $_.Directory.Name
                }
            }
            Write-TacticsLog -Level "INFO" -Message "Found $($files.Count) $($scan.Type) files" -Component "Scanner"
        }
    }
    
    # Process files with progress
    $decisions = [System.Collections.ArrayList]::new()
    $consultations = [System.Collections.ArrayList]::new()
    $actions = [System.Collections.ArrayList]::new()
    $idRegistry = @{}
    $crossRefs = [System.Collections.ArrayList]::new()
    $processedCount = 0
    
    foreach ($fileInfo in $allFiles) {
        $processedCount++
        Write-Progress -Activity "Rebuilding Index" -Status "Processing $($fileInfo.RelativePath)" `
            -PercentComplete (($processedCount / $allFiles.Count) * 100)
        
        Write-TacticsLog -Level "DEBUG" -Message "Processing: $($fileInfo.RelativePath)" -Component "Parser"
        
        # Extract metadata
        $metadata = Get-TacticsFileMetadata -FilePath $fileInfo.Path
        $metadata['FileType'] = $fileInfo.Type
        $metadata['Category'] = $fileInfo.Category
        $metadata['RelativePath'] = $fileInfo.RelativePath
        
        # Validate
        $validationErrors = Test-DecisionIntegrity -Metadata $metadata -FilePath $fileInfo.Path
        if ($validationErrors.Count -gt 0) {
            $Script:RebuildErrors.AddRange($validationErrors)
        }
        
        # Check for duplicate IDs
        if ($metadata.ContainsKey('DecisionId')) {
            $decId = $metadata['DecisionId']
            if ($idRegistry.ContainsKey($decId)) {
                $Script:RebuildErrors.Add([RebuildError]::new(
                    $fileInfo.Path,
                    "DuplicateId",
                    "Duplicate DecisionId: $decId (also found in $($idRegistry[$decId]))",
                    [RebuildErrorSeverity]::CRITICAL,
                    "Assign new unique ID using ID allocator"
                ))
            } else {
                $idRegistry[$decId] = $fileInfo.RelativePath
            }
        }
        
        # Build cross-reference map
        if ($metadata.ContainsKey('References')) {
            foreach ($ref in $metadata['References']) {
                $crossRefs.Add(@{
                    Source = $fileInfo.RelativePath
                    Target = $ref
                    Type = $fileInfo.Type
                }) | Out-Null
            }
        }
        
        # Categorize
        switch ($fileInfo.Type) {
            'decision' { $decisions.Add($metadata) | Out-Null }
            'consultation' { $consultations.Add($metadata) | Out-Null }
            'action' { $actions.Add($metadata) | Out-Null }
        }
        
        # Checkpoint periodically
        if ($processedCount % $CheckpointInterval -eq 0) {
            $state = @{
                Decisions = $decisions
                Consultations = $consultations
                Actions = $actions
                IdRegistry = $idRegistry
                CrossRefs = $crossRefs
                ProcessedCount = $processedCount
            }
            if (-not $DryRun) {
                Save-Checkpoint -State $state -FileNumber $processedCount
            }
        }
    }
    
    Write-Progress -Activity "Rebuilding Index" -Completed
    
    # Validate cross-references
    $brokenRefs = $crossRefs | Where-Object { -not $idRegistry.ContainsKey($_.Target) }
    foreach ($broken in $brokenRefs) {
        $Script:RebuildErrors.Add([RebuildError]::new(
            $broken.Source,
            "BrokenReference",
            "Reference to non-existent target: $($broken.Target)",
            [RebuildErrorSeverity]::WARNING,
            "Create target file or remove reference"
        ))
    }
    
    # Check for orphaned files (not referenced by anything)
    $orphaned = $idRegistry.Keys | Where-Object { 
        $id = $_
        -not ($crossRefs | Where-Object { $_.Target -eq $id })
    }
    
    # Generate output files
    $indexData = @{
        GeneratedAt = [datetime]::UtcNow.ToString("o")
        SchemaVersion = $Script:Config.MetadataVersion
        Decisions = $decisions
        Consultations = $consultations
        Actions = $actions
        IdRegistry = $idRegistry
        CrossReferences = $crossRefs
        Statistics = @{
            TotalFiles = $allFiles.Count
            Decisions = $decisions.Count
            Consultations = $consultations.Count
            Actions = $actions.Count
            OrphanedFiles = @($orphaned).Count
            BrokenReferences = @($brokenRefs).Count
        }
        Health = @{
            Status = if ($Script:RebuildErrors | Where-Object { $_.Severity -eq [RebuildErrorSeverity]::CRITICAL }) { "CRITICAL" }
                     elseif ($Script:RebuildErrors.Count -gt 0) { "WARNING" }
                     else { "HEALTHY" }
            ErrorCount = $Script:RebuildErrors.Count
            CriticalErrors = @($Script:RebuildErrors | Where-Object { $_.Severity -eq [RebuildErrorSeverity]::CRITICAL }).Count
        }
    }
    
    # Write index files
    if (-not $DryRun) {
        # Write consolidated index
        $indexData | ConvertTo-Json -Depth 20 | `
            Set-Content -Path (Join-Path $indexDir "tactics-index.json") -Encoding UTF8
        
        # Write individual catalogs
        @{ items = $decisions; count = $decisions.Count; generated = $indexData.GeneratedAt } | `
            ConvertTo-Json -Depth 10 | Set-Content -Path (Join-Path $indexDir "decisions.json")
        
        @{ items = $consultations; count = $consultations.Count; generated = $indexData.GeneratedAt } | `
            ConvertTo-Json -Depth 10 | Set-Content -Path (Join-Path $indexDir "consultations.json")
        
        @{ items = $actions; count = $actions.Count; generated = $indexData.GeneratedAt } | `
            ConvertTo-Json -Depth 10 | Set-Content -Path (Join-Path $indexDir "actions.json")
        
        # Write references
        @{ references = $crossRefs; broken = $brokenRefs; generated = $indexData.GeneratedAt } | `
            ConvertTo-Json -Depth 10 | Set-Content -Path (Join-Path $indexDir "references.json")
        
        # Write health status
        $indexData.Health | ConvertTo-Json | `
            Set-Content -Path (Join-Path $indexDir "health.json")
        
        # Write error log if errors exist
        if ($Script:RebuildErrors.Count -gt 0) {
            @{ errors = $Script:RebuildErrors; generated = $indexData.GeneratedAt } | `
                ConvertTo-Json -Depth 10 | Set-Content -Path (Join-Path $indexDir "errors.json")
        }
        
        Write-TacticsLog -Level "INFO" -Message "Index files written to $indexDir" -Component "Writer"
    }
    
    # Report results
    Write-TacticsLog -Level "INFO" -Message "=== REBUILD COMPLETE ===" -Component "Rebuild"
    Write-TacticsLog -Level "INFO" -Message "Files processed: $($allFiles.Count)" -Component "Stats"
    Write-TacticsLog -Level "INFO" -Message "Decisions: $($decisions.Count)" -Component "Stats"
    Write-TacticsLog -Level "INFO" -Message "Consultations: $($consultations.Count)" -Component "Stats"
    Write-TacticsLog -Level "INFO" -Message "Actions: $($actions.Count)" -Component "Stats"
    Write-TacticsLog -Level "INFO" -Message "Health Status: $($indexData.Health.Status)" -Component "Stats"
    Write-TacticsLog -Level "INFO" -Message "Total Errors: $($Script:RebuildErrors.Count)" -Component "Stats"
    
    if ($Script:RebuildErrors.Count -gt 0) {
        Write-TacticsLog -Level "WARN" -Message "Errors detected:" -Component "Stats"
        $Script:RebuildErrors | Group-Object Severity | ForEach-Object {
            Write-TacticsLog -Level $_.Name -Message "$($_.Count) $($_.Name.ToLower()) errors" -Component "Stats"
        }
    }
    
    return $indexData
}

# Detect index corruption
function Test-IndexCorruption {
    $indexPath = Join-Path $RootPath $Script:Config.IndexDir
    
    if (-not (Test-Path $indexPath)) {
        return @{ IsCorrupt = $true; Reason = "Index directory missing" }
    }
    
    $requiredFiles = @("tactics-index.json", "health.json")
    foreach ($file in $requiredFiles) {
        $path = Join-Path $indexPath $file
        if (-not (Test-Path $path)) {
            return @{ IsCorrupt = $true; Reason = "Missing required file: $file" }
        }
        
        try {
            $content = Get-Content $path -Raw | ConvertFrom-Json
            if ($null -eq $content) {
                return @{ IsCorrupt = $true; Reason = "Empty or invalid JSON: $file" }
            }
        } catch {
            return @{ IsCorrupt = $true; Reason = "Corrupted JSON in: $file - $($_.Exception.Message)" }
        }
    }
    
    # Check health status
    $health = Get-Content (Join-Path $indexPath "health.json") -Raw | ConvertFrom-Json
    if ($health.Status -eq "CRITICAL") {
        return @{ IsCorrupt = $true; Reason = "Health status is CRITICAL" }
    }
    
    return @{ IsCorrupt = $false; Reason = "Index healthy" }
}

# Main execution
$corruptionCheck = Test-IndexCorruption
if ($corruptionCheck.IsCorrupt -and -not $Force) {
    Write-TacticsLog -Level "ERROR" -Message "Index corruption detected: $($corruptionCheck.Reason)" -Component "Validation"
    Write-TacticsLog -Level "INFO" -Message "Use -Force to rebuild anyway, or fix the underlying issue first." -Component "Validation"
    exit 1
}

# Execute rebuild
$result = Start-IndexRebuild

# Exit with appropriate code
if ($result.Health.Status -eq "CRITICAL") {
    exit 2
} elseif ($result.Health.Status -eq "WARNING") {
    exit 1
} else {
    exit 0
}
```

## 1.3 Trigger Configuration

Create `.github/workflows/rebuild-index.yml`:

```yaml
name: Rebuild TACTICS Index

on:
  # Trigger 1: Push to main affecting decision files
  push:
    branches: [ main, develop ]
    paths:
      - 'T4CT1CS/decisions/**/*.md'
      - 'T4CT1CS/consultations/**/*.md'
      - 'T4CT1CS/actions/**/*.md'
  
  # Trigger 2: Manual trigger
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode'
        type: boolean
        default: false
      force:
        description: 'Force rebuild even if corrupt'
        type: boolean
        default: false
  
  # Trigger 3: Scheduled (nightly consistency check)
  schedule:
    - cron: '0 2 * * *'  # 2 AM daily

jobs:
  rebuild:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup PowerShell
        uses: actions/setup-powershell@v2
      
      - name: Rebuild Index
        run: |
          .\T4CT1CS\scripts\Rebuild-TacticsIndex.ps1 `
            -RootPath ".\T4CT1CS" `
            -DryRun:${{ github.event.inputs.dry_run }} `
            -Force:${{ github.event.inputs.force }}
        continue-on-error: true
        id: rebuild
      
      - name: Upload Index Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tactics-index
          path: T4CT1CS/.index/
      
      - name: Check Health Status
        run: |
          $health = Get-Content .\T4CT1CS\.index\health.json | ConvertFrom-Json
          if ($health.Status -eq "CRITICAL") {
            Write-Error "Index is in CRITICAL state"
            exit 1
          }
          Write-Host "Index health: $($health.Status)"
      
      - name: Commit Updated Index
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          git config user.name "Tactics Bot"
          git config user.email "tactics@p4nth30n.local"
          git add T4CT1CS/.index/
          git diff --staged --quiet || git commit -m "chore: rebuild tactics index [automated]"
          git push
```

## 1.4 Recovery Procedures

**Automatic Recovery Flow:**

```
┌────────────────────────────────────────────────────────────┐
│                    RECOVERY WORKFLOW                       │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  Detection                    Assessment                   │
│     │                             │                        │
│     ▼                             ▼                        │
│ ┌──────────┐              ┌──────────────┐                │
│ │ Corrupt  │─────────────▶│  Check       │                │
│ │ Index?   │              │  Checkpoints │                │
│ └──────────┘              └──────────────┘                │
│                                  │                         │
│                                  ▼                         │
│                         ┌────────────────┐                │
│                         │ Valid          │                │
│                         │ Checkpoint?    │                │
│                         └────────────────┘                │
│                                │                          │
│                    ┌──────────┴──────────┐                │
│                    ▼                     ▼                │
│               ┌─────────┐          ┌──────────┐          │
│               │  YES    │          │    NO    │          │
│               └────┬────┘          └────┬─────┘          │
│                    ▼                    │                │
│            ┌─────────────┐              │                │
│            │ Restore     │              │                │
│            │ Checkpoint  │              ▼                │
│            └──────┬──────┘      ┌─────────────┐         │
│                   │             │ Full Rebuild│         │
│                   │             │ From Source │         │
│                   │             └──────┬──────┘         │
│                   │                    │                │
│                   └──────────┬─────────┘                │
│                              ▼                           │
│                    ┌─────────────────┐                  │
│                    │ Validate Result │                  │
│                    └────────┬────────┘                  │
│                             │                            │
│                   ┌────────┴────────┐                    │
│                   ▼                 ▼                    │
│             ┌──────────┐    ┌──────────┐                │
│             │ SUCCESS  │    │  FAIL    │                │
│             └────┬─────┘    └────┬─────┘                │
│                  ▼               │                       │
│            ┌──────────┐          │                       │
│            │ Complete │◄─────────┘ (Alert + Manual)     │
│            └──────────┘                                  │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

# PART 2: ID SEQUENCING AND ALLOCATION SYSTEM

## 2.1 Architecture: Centralized ID Allocator

```
┌─────────────────────────────────────────────────────────────┐
│                  ID ALLOCATION SYSTEM                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              ID REGISTRY (id-registry.json)          │   │
│  │  ┌─────────────────────────────────────────────────┐ │   │
│  │  │  {                                              │ │   │
│  │  │    "version": "1.0.0",                          │ │   │
│  │  │    "lastUpdated": "2026-02-18T21:15:00Z",       │ │   │
│  │  │    "sequences": {                               │ │   │
│  │  │      "FORGE": { "next": 2, "allocated": [1] },  │ │   │
│  │  │      "TECH": { "next": 47, "allocated": [...] },│ │   │
│  │  │      "COMP": { "next": 12, "allocated": [...] },│ │   │
│  │  │      "IMPL": { "next": 156, "allocated": [...] }│ │   │
│  │  │    },                                           │ │   │
│  │  │    "reservations": [                            │ │   │
│  │  │      {                                          │ │   │
│  │  │        "id": "TECH-100",                        │ │   │
│  │  │        "reservedBy": "windsurf-batch-001",      │ │   │
│  │  │        "reservedAt": "2026-02-18T20:00:00Z",    │ │   │
│  │  │        "expiresAt": "2026-02-18T22:00:00Z",     │ │   │
│  │  │        "status": "pending"                      │ │   │
│  │  │      }                                          │ │   │
│  │  │    ]                                            │ │   │
│  │  │  }                                              │ │   │
│  │  └─────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────┘   │
│                             │                               │
│                             ▼                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │            ALLOCATION API (PowerShell Module)        │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │   │
│  │  │  Reserve    │  │   Claim     │  │   Query     │  │   │
│  │  │  IDs        │  │   ID        │  │   Status    │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  │   │
│  └─────────────────────────────────────────────────────┘   │
│                             │                               │
│                             ▼                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │            FILE LOCK MECHANISM                       │   │
│  │  ┌─────────────┐    ┌─────────────────────────────┐ │   │
│  │  │  Atomic     │───▶│  Lock File:                 │ │   │
│  │  │  File       │    │  .index/.id-registry.lock   │ │   │
│  │  │  Operations │    │                             │ │   │
│  │  └─────────────┘    │  {                          │ │   │
│  │                     │    "lockedBy": "PID-12345", │ │   │
│  │                     │    "lockedAt": "...",       │ │   │
│  │                     │    "timeout": 30            │ │   │
│  │                     │  }                          │ │   │
│  │                     └─────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 2.2 PowerShell Implementation: `TacticsIdAllocator.psm1`

```powershell
# TacticsIdAllocator.psm1
# Centralized ID allocation module for TACTICS framework

$Script:Config = @{
    RegistryFile = ".index/id-registry.json"
    LockFile = ".index/.id-registry.lock"
    LockTimeoutSeconds = 30
    ReservationTimeoutMinutes = 120
}

# Lock Management
function Lock-IdRegistry {
    param(
        [int]$TimeoutSeconds = $Script:Config.LockTimeoutSeconds,
        [int]$RetryDelayMs = 100
    )
    
    $lockPath = Join-Path $PWD $Script:Config.LockFile
    $lockDir = Split-Path $lockPath -Parent
    if (-not (Test-Path $lockDir)) {
        New-Item -ItemType Directory -Path $lockDir -Force | Out-Null
    }
    
    $startTime = Get-Date
    $processId = $PID
    
    while (((Get-Date) - $startTime).TotalSeconds -lt $TimeoutSeconds) {
        try {
            # Try to create exclusive lock
            $lockContent = @{
                lockedBy = $processId
                lockedAt = (Get-Date -Format "o")
                timeout = $TimeoutSeconds
            } | ConvertTo-Json
            
            # Use [System.IO.File]::WriteAllText with FileShare.None for atomicity
            $bytes = [System.Text.Encoding]::UTF8.GetBytes($lockContent)
            $stream = [System.IO.File]::Open($lockPath, [System.IO.FileMode]::CreateNew, 
                [System.IO.FileAccess]::Write, [System.IO.FileShare]::None)
            $stream.Write($bytes, 0, $bytes.Length)
            $stream.Close()
            $stream.Dispose()
            
            return @{ Success = $true; LockPath = $lockPath }
        }
        catch [System.IO.IOException] {
            # Lock exists, check if stale
            if (Test-Path $lockPath) {
                try {
                    $existingLock = Get-Content $lockPath -Raw | ConvertFrom-Json
                    $lockAge = [datetime]::UtcNow - [datetime]::Parse($existingLock.lockedAt)
                    if ($lockAge.TotalSeconds -gt ($existingLock.timeout * 2)) {
                        # Stale lock, remove it
                        Remove-Item $lockPath -Force
                        Write-Verbose "Removed stale lock from $($existingLock.lockedBy)"
                        continue
                    }
                } catch {
                    # Corrupt lock file, remove it
                    Remove-Item $lockPath -Force
                    continue
                }
            }
            
            Start-Sleep -Milliseconds $RetryDelayMs
        }
    }
    
    return @{ Success = $false; Error = "Timeout waiting for registry lock" }
}

function Unlock-IdRegistry {
    param([string]$LockPath)
    if (Test-Path $LockPath) {
        Remove-Item $LockPath -Force
    }
}

# Registry Operations
function Get-IdRegistry {
    $registryPath = Join-Path $PWD $Script:Config.RegistryFile
    
    if (-not (Test-Path $registryPath)) {
        # Initialize new registry
        return @{
            version = "1.0.0"
            lastUpdated = [datetime]::UtcNow.ToString("o")
            sequences = @{}
            reservations = @()
            allocations = @()
        }
    }
    
    return Get-Content $registryPath -Raw | ConvertFrom-Json -AsHashtable
}

function Save-IdRegistry {
    param([hashtable]$Registry)
    $registryPath = Join-Path $PWD $Script:Config.RegistryFile
    $registry.lastUpdated = [datetime]::UtcNow.ToString("o")
    
    # Write atomically
    $tempPath = "$registryPath.tmp"
    $Registry | ConvertTo-Json -Depth 10 | Set-Content -Path $tempPath -Encoding UTF8
    Move-Item -Path $tempPath -Destination $registryPath -Force
}

# Public API Functions
function New-TacticsId {
    <#
    .SYNOPSIS
        Allocates a new unique TACTICS ID.
    .DESCRIPTION
        Atomically reserves and returns the next available ID for a given prefix.
    .PARAMETER Prefix
        The ID prefix (e.g., "FORGE", "TECH", "COMP", "IMPL")
    .PARAMETER Count
        Number of IDs to allocate (default: 1)
    .PARAMETER Reserve
        If set, only reserve the IDs without claiming them
    .PARAMETER ReserveFor
        Identifier for who/what reserved the IDs
    .EXAMPLE
        New-TacticsId -Prefix "TECH" -Count 5
        Returns: @("TECH-47", "TECH-48", "TECH-49", "TECH-50", "TECH-51")
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("FORGE", "TECH", "COMP", "IMPL", "TEST", "DOC", "ARCH")]
        [string]$Prefix,
        
        [int]$Count = 1,
        [switch]$Reserve,
        [string]$ReserveFor = "manual"
    )
    
    # Acquire lock
    $lock = Lock-IdRegistry
    if (-not $lock.Success) {
        throw "Failed to acquire ID registry lock: $($lock.Error)"
    }
    
    try {
        $registry = Get-IdRegistry
        
        # Initialize sequence if needed
        if (-not $registry.sequences.ContainsKey($Prefix)) {
            $registry.sequences[$Prefix] = @{
                next = 1
                allocated = @()
            }
        }
        
        $sequence = $registry.sequences[$Prefix]
        $allocatedIds = @()
        
        for ($i = 0; $i -lt $Count; $i++) {
            $id = "$Prefix-$($sequence.next)"
            $sequence.next++
            $sequence.allocated += $id
            $allocatedIds += $id
            
            # Record allocation
            $registry.allocations += @{
                id = $id
                prefix = $Prefix
                allocatedAt = [datetime]::UtcNow.ToString("o")
                allocatedBy = if ($Reserve) { $ReserveFor } else { $env:USERNAME }
                status = if ($Reserve) { "reserved" } else { "active" }
            }
        }
        
        # If reserving, add to reservations list
        if ($Reserve) {
            $reservation = @{
                ids = $allocatedIds
                reservedBy = $ReserveFor
                reservedAt = [datetime]::UtcNow.ToString("o")
                expiresAt = ([datetime]::UtcNow.AddMinutes($Script:Config.ReservationTimeoutMinutes)).ToString("o")
                status = "pending"
            }
            $registry.reservations += $reservation
        }
        
        Save-IdRegistry -Registry $registry
        
        return $allocatedIds
    }
    finally {
        Unlock-IdRegistry -LockPath $lock.LockPath
    }
}

function Get-TacticsIdStatus {
    <#
    .SYNOPSIS
        Queries the status of one or more TACTICS IDs.
    #>
    param(
        [Parameter(ValueFromPipeline = $true)]
        [string]$Id
    )
    
    process {
        $registry = Get-IdRegistry
        
        # Check if allocated
        $allocation = $registry.allocations | Where-Object { $_.id -eq $Id }
        
        # Check if reserved
        $reservation = $registry.reservations | Where-Object { 
            $_.ids -contains $Id -and $_.status -eq "pending" 
        }
        
        [PSCustomObject]@{
            Id = $Id
            Status = if ($reservation) { "reserved" } 
                     elseif ($allocation) { $allocation.status }
                     else { "available" }
            AllocatedAt = $allocation?.allocatedAt
            AllocatedBy = $allocation?.allocatedBy
            ExpiresAt = $reservation?.expiresAt
        }
    }
}

function Confirm-TacticsIdReservation {
    <#
    .SYNOPSIS
        Converts a reserved ID to active status.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Id,
        
        [string]$ConfirmedBy = $env:USERNAME
    )
    
    $lock = Lock-IdRegistry
    if (-not $lock.Success) {
        throw "Failed to acquire ID registry lock"
    }
    
    try {
        $registry = Get-IdRegistry
        
        # Update allocation status
        $allocation = $registry.allocations | Where-Object { $_.id -eq $Id }
        if ($allocation) {
            $allocation.status = "active"
            $allocation.confirmedAt = [datetime]::UtcNow.ToString("o")
            $allocation.confirmedBy = $ConfirmedBy
        }
        
        # Remove from reservations
        $registry.reservations = $registry.reservations | Where-Object {
            $_.ids -notcontains $Id
        }
        
        Save-IdRegistry -Registry $registry
        return $true
    }
    finally {
        Unlock-IdRegistry -LockPath $lock.LockPath
    }
}

function Remove-ExpiredReservations {
    <#
    .SYNOPSIS
        Cleans up expired reservations and makes IDs available again.
    #>
    $lock = Lock-IdRegistry
    if (-not $lock.Success) {
        throw "Failed to acquire ID registry lock"
    }
    
    try {
        $registry = Get-IdRegistry
        $now = [datetime]::UtcNow
        $expired = @()
        
        $registry.reservations = $registry.reservations | Where-Object {
            $expires = [datetime]::Parse($_.expiresAt)
            if ($expires -lt $now) {
                $expired += $_.ids
                $false  # Remove from reservations
            } else {
                $true   # Keep
            }
        }
        
        # Mark allocations as expired
        foreach ($id in $expired) {
            $allocation = $registry.allocations | Where-Object { $_.id -eq $id }
            if ($allocation) {
                $allocation.status = "expired"
            }
        }
        
        if ($expired.Count -gt 0) {
            Save-IdRegistry -Registry $registry
            Write-Verbose "Cleaned up $($expired.Count) expired reservations"
        }
        
        return $expired
    }
    finally {
        Unlock-IdRegistry -LockPath $lock.LockPath
    }
}

# Export public functions
Export-ModuleMember -Function @(
    'New-TacticsId',
    'Get-TacticsIdStatus', 
    'Confirm-TacticsIdReservation',
    'Remove-ExpiredReservations'
)
```

## 2.3 ID Reservation for WindSurf Batches

```powershell
# Example: Reserve block of IDs for WindSurf session
Import-Module .\T4CT1CS\scripts\TacticsIdAllocator.psm1

# Reserve 10 IDs for a batch operation
$reservedIds = New-TacticsId -Prefix "TECH" -Count 10 -Reserve -ReserveFor "windsurf-session-$(Get-Random)"
Write-Host "Reserved IDs: $($reservedIds -join ', ')"

# Later, confirm each as they're used
foreach ($id in $reservedIds) {
    # Create the decision file...
    # Then confirm the reservation
    Confirm-TacticsIdReservation -Id $id -ConfirmedBy "WindSurf"
}
```

---

# PART 3: PATH ALIAS AND REDIRECT SYSTEM

## 3.1 Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                  PATH ALIAS SYSTEM                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │           ALIAS REGISTRY (aliases.json)                  │   │
│  │  ┌─────────────────────────────────────────────────────┐ │   │
│  │  │  {                                                  │ │   │
│  │  │    "version": "1.0.0",                              │ │   │
│  │  │    "aliases": {                                     │ │   │
│  │  │      "FORGE-001": {                                 │ │   │
│  │  │        "current": "decisions/active/FORGE-001.md",  │ │   │
│  │  │        "history": [                                 │ │   │
│  │  │          "decisions/archive/v1/FORGE-001.md"        │ │   │
│  │  │        ],                                           │ │   │
│  │  │        "redirects": [                               │ │   │
│  │  │          {                                          │ │   │
│  │  │            "from": "briefs/FORGE-001.md",           │ │   │
│  │  │            "to": "decisions/active/FORGE-001.md",   │ │   │
│  │  │            "type": "moved",                         │ │   │
│  │  │            "created": "2026-02-18T21:15:00Z"        │ │   │
│  │  │          }                                          │ │   │
│  │  │        ]                                            │ │   │
│  │  │      }                                              │ │   │
│  │  │    },                                               │ │   │
│  │  │    "patterns": [                                    │ │   │
│  │  │      {                                              │ │   │
│  │  │        "match": "decisions/*/FORGE-*.md",           │ │   │
│  │  │        "canonical": "decisions/active/{id}.md"      │ │   │
│  │  │      }                                              │ │   │
│  │  │    ]                                                │ │   │
│  │  │  }                                                  │ │   │
│  │  └─────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              RESOLUTION ENGINE                           │   │
│  │                                                          │   │
│  │  1. Exact Match      → Direct lookup in aliases         │   │
│  │  2. Pattern Match    → Apply pattern rules              │   │
│  │  3. History Lookup   → Check previous locations         │   │
│  │  4. Fuzzy Match      → Suggest similar paths            │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │         VALIDATION & MAINTENANCE                         │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │ Detect      │  │ Check       │  │ Report          │  │   │
│  │  │ Circular    │  │ Targets     │  │ Orphaned        │  │   │
│  │  │ Redirects   │  │ Exist       │  │ Aliases         │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 3.2 PowerShell Implementation: `TacticsPathResolver.psm1`

```powershell
# TacticsPathResolver.psm1
# Path resolution with alias support

$Script:AliasCache = $null
$Script:CacheTimestamp = $null
$Script:CacheTTL = 60  # seconds

function Get-AliasRegistry {
    param([switch]$ForceRefresh)
    
    $registryPath = Join-Path $PWD ".index/aliases.json"
    $now = [datetime]::UtcNow
    
    # Use cache if valid
    if (-not $ForceRefresh -and 
        $Script:AliasCache -and 
        $Script:CacheTimestamp -and
        ($now - $Script:CacheTimestamp).TotalSeconds -lt $Script:CacheTTL) {
        return $Script:AliasCache
    }
    
    if (-not (Test-Path $registryPath)) {
        $Script:AliasCache = @{ aliases = @{}; patterns = @() }
        $Script:CacheTimestamp = $now
        return $Script:AliasCache
    }
    
    $Script:AliasCache = Get-Content $registryPath -Raw | ConvertFrom-Json -AsHashtable
    $Script:CacheTimestamp = $now
    return $Script:AliasCache
}

function Resolve-TacticsPath {
    <#
    .SYNOPSIS
        Resolves a potentially aliased path to its canonical location.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path,
        
        [switch]$ReturnAllMatches,
        [switch]$CreateRedirectOnMove
    )
    
    $aliases = Get-AliasRegistry
    $cleanPath = $Path -replace "^\./", "" -replace "^/", ""
    
    # Check 1: Direct alias lookup by decision ID
    if ($cleanPath -match "([A-Z]+-\d+)") {
        $decisionId = $matches[1]
        if ($aliases.aliases.ContainsKey($decisionId)) {
            $alias = $aliases.aliases[$decisionId]
            
            # Check if this is a redirect request
            $redirect = $alias.redirects | Where-Object { $_.from -eq $cleanPath }
            if ($redirect) {
                return [PSCustomObject]@{
                    OriginalPath = $Path
                    ResolvedPath = $redirect.to
                    DecisionId = $decisionId
                    Type = "redirect"
                    RedirectInfo = $redirect
                }
            }
            
            # Return current canonical path
            return [PSCustomObject]@{
                OriginalPath = $Path
                ResolvedPath = $alias.current
                DecisionId = $decisionId
                Type = "canonical"
                History = $alias.history
            }
        }
    }
    
    # Check 2: Pattern matching
    foreach ($pattern in $aliases.patterns) {
        if ($cleanPath -like $pattern.match) {
            $resolved = $cleanPath -replace $pattern.match, $pattern.canonical
            return [PSCustomObject]@{
                OriginalPath = $Path
                ResolvedPath = $resolved
                Type = "pattern"
                Pattern = $pattern
            }
        }
    }
    
    # Check 3: Direct file existence
    $fullPath = Join-Path $PWD $cleanPath
    if (Test-Path $fullPath) {
        return [PSCustomObject]@{
            OriginalPath = $Path
            ResolvedPath = $cleanPath
            Type = "direct"
        }
    }
    
    # Check 4: Fuzzy match suggestions
    $suggestions = Find-SimilarPaths -Path $cleanPath -Aliases $aliases
    
    return [PSCustomObject]@{
        OriginalPath = $Path
        ResolvedPath = $null
        Type = "not-found"
        Suggestions = $suggestions
    }
}

function Register-PathMove {
    <#
    .SYNOPSIS
        Registers a path move and creates a redirect entry.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$From,
        
        [Parameter(Mandatory = $true)]
        [string]$To,
        
        [string]$DecisionId,
        [string]$Reason = "reorganization",
        [switch]$MoveFile
    )
    
    $aliases = Get-AliasRegistry -ForceRefresh
    
    # Initialize alias entry if needed
    if (-not $aliases.aliases.ContainsKey($DecisionId)) {
        $aliases.aliases[$DecisionId] = @{
            current = $To
            history = @()
            redirects = @()
        }
    }
    
    $alias = $aliases.aliases[$DecisionId]
    
    # Update current path and history
    if ($alias.current -and $alias.current -ne $To) {
        $alias.history += $alias.current
    }
    $alias.current = $To
    
    # Add redirect entry
    $alias.redirects += @{
        from = $From
        to = $To
        type = $Reason
        created = [datetime]::UtcNow.ToString("o")
    }
    
    # Save registry
    $registryPath = Join-Path $PWD ".index/aliases.json"
    $aliases | ConvertTo-Json -Depth 10 | Set-Content -Path $registryPath -Encoding UTF8
    
    # Optionally move the actual file
    if ($MoveFile -and (Test-Path $From)) {
        $destDir = Split-Path $To -Parent
        if (-not (Test-Path $destDir)) {
            New-Item -ItemType Directory -Path $destDir -Force | Out-Null
        }
        Move-Item -Path $From -Destination $To -Force
    }
    
    # Invalidate cache
    $Script:AliasCache = $null
    
    return [PSCustomObject]@{
        DecisionId = $DecisionId
        From = $From
        To = $To
        RedirectCreated = $true
    }
}

function Test-PathAliases {
    <#
    .SYNOPSIS
        Validates the entire alias registry for issues.
    #>
    $aliases = Get-AliasRegistry -ForceRefresh
    $issues = @()
    
    foreach ($entry in $aliases.aliases.GetEnumerator()) {
        $decisionId = $entry.Key
        $alias = $entry.Value
        
        # Check current path exists
        $currentFullPath = Join-Path $PWD $alias.current
        if (-not (Test-Path $currentFullPath)) {
            $issues += [PSCustomObject]@{
                Type = "missing-target"
                DecisionId = $decisionId
                Path = $alias.current
                Severity = "error"
                Message = "Current path does not exist: $($alias.current)"
            }
        }
        
        # Check for circular redirects
        $visited = @()
        $current = $alias.current
        while ($true) {
            if ($visited -contains $current) {
                $issues += [PSCustomObject]@{
                    Type = "circular-redirect"
                    DecisionId = $decisionId
                    Path = $current
                    Severity = "critical"
                    Message = "Circular redirect detected"
                }
                break
            }
            $visited += $current
            
            # Check if this path redirects elsewhere
            $redirectingAlias = $aliases.aliases.GetEnumerator() | Where-Object {
                $_.Value.redirects | Where-Object { $_.to -eq $current }
            } | Select-Object -First 1
            
            if (-not $redirectingAlias) { break }
            $current = $redirectingAlias.Value.current
        }
        
        # Check for orphaned redirects (target of redirect doesn't exist)
        foreach ($redirect in $alias.redirects) {
            $fromFullPath = Join-Path $PWD $redirect.from
            if (Test-Path $fromFullPath) {
                $issues += [PSCustomObject]@{
                    Type = "orphaned-file"
                    DecisionId = $decisionId
                    Path = $redirect.from
                    Severity = "warning"
                    Message = "File exists at old path but redirect exists"
                }
            }
        }
    }
    
    return $issues
}

function Find-SimilarPaths {
    param([string]$Path, [hashtable]$Aliases)
    
    $pathParts = $Path -split "[/\\]"
    $filename = $pathParts[-1]
    
    $suggestions = @()
    
    # Check for similar filenames in registry
    foreach ($entry in $Aliases.aliases.GetEnumerator()) {
        if ($entry.Value.current -like "*$filename*" -or 
            $filename -like "*$($entry.Key)*") {
            $suggestions += $entry.Value.current
        }
    }
    
    # Check for similar paths
    foreach ($part in $pathParts) {
        $matching = $Aliases.aliases.GetEnumerator() | Where-Object {
            $_.Value.current -like "*$part*"
        } | Select-Object -ExpandProperty Value | Select-Object -ExpandProperty current
        $suggestions += $matching
    }
    
    return $suggestions | Select-Object -Unique | Select-Object -First 5
}

Export-ModuleMember -Function @(
    'Resolve-TacticsPath',
    'Register-PathMove',
    'Test-PathAliases',
    'Get-AliasRegistry'
)
```

## 3.3 Redirect Resolution in Git Hook

```powershell
# .git/hooks/post-checkout (partial)
# Resolve any redirects after branch checkout

Import-Module .\T4CT1CS\scripts\TacticsPathResolver.psm1

$aliases = Get-AliasRegistry
$redirectsApplied = 0

foreach ($entry in $aliases.aliases.GetEnumerator()) {
    foreach ($redirect in $entry.Value.redirects) {
        $fromPath = Join-Path $PWD $redirect.from
        if (Test-Path $fromPath) {
            # Create/update symlink or placeholder redirect file
            $redirectContent = @"
# REDIRECT
# This file has been moved to: $($redirect.to)
# Created: $($redirect.created)
# Reason: $($redirect.type)

See: [$($redirect.to)](./$($redirect.to))
"@
            Set-Content -Path $fromPath -Value $redirectContent -Encoding UTF8
            $redirectsApplied++
        }
    }
}

if ($redirectsApplied -gt 0) {
    Write-Host "Applied $redirectsApplied path redirects" -ForegroundColor Yellow
}
```

---

# PART 4: VALIDATION PIPELINE ARCHITECTURE

## 4.1 Staged Validation System

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      VALIDATION PIPELINE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Stage 0: MIGRATION MODE                                                   │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  • All validation DISABLED                                          │   │
│   │  • Used during mass migration operations                            │   │
│   │  • Errors logged but not blocking                                   │   │
│   │  • Can be set via: $env:TACTICS_VALIDATION_MODE="migration"       │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│   Stage 1: WARNING MODE                                                     │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  • All validations run                                              │   │
│   │  • Issues logged as WARNINGS                                        │   │
│   │  • Writes ALLOWED with warnings                                     │   │
│   │  • Daily report of all warnings                                     │   │
│   │  • Trigger: $env:TACTICS_VALIDATION_MODE="warning"                │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│   Stage 2: SOFT ENFORCEMENT                                                 │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  • Issues require confirmation                                      │   │
│   │  • "Are you sure? (y/N)" prompts                                    │   │
│   │  • Audit trail of overrides                                         │   │
│   │  • Override requires reason                                         │   │
│   │  • Trigger: $env:TACTICS_VALIDATION_MODE="soft"                   │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│   Stage 3: HARD ENFORCEMENT                                                 │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  • All validations MUST pass                                        │   │
│   │  • NO overrides allowed                                             │   │
│   │  • CI/CD gate requires clean validation                             │   │
│   │  • Emergency bypass requires admin approval                         │   │
│   │  • Trigger: $env:TACTICS_VALIDATION_MODE="strict" (default)       │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 4.2 Validation Rules Configuration

```powershell
# validation-rules.json
{
  "version": "1.0.0",
  "defaultMode": "soft",
  "rules": {
    "requiredHeaders": {
      "severity": "error",
      "appliesTo": ["decision", "consultation"],
      "fields": ["DecisionId", "Status", "Created", "Author"],
      "stages": {
        "migration": "skip",
        "warning": "log",
        "soft": "confirm",
        "strict": "block"
      }
    },
    "idFormat": {
      "severity": "error", 
      "appliesTo": ["all"],
      "pattern": "^[A-Z]+-[0-9]+$",
      "stages": {
        "migration": "skip",
        "warning": "log",
        "soft": "confirm",
        "strict": "block"
      }
    },
    "crossReferences": {
      "severity": "warning",
      "appliesTo": ["all"],
      "checkExists": true,
      "stages": {
        "migration": "skip",
        "warning": "log",
        "soft": "confirm",
        "strict": "block"
      }
    },
    "orphanedFiles": {
      "severity": "info",
      "appliesTo": ["all"],
      "stages": {
        "migration": "skip",
        "warning": "log",
        "soft": "log",
        "strict": "log"
      }
    },
    "directoryStructure": {
      "severity": "error",
      "appliesTo": ["all"],
      "allowedPaths": [
        "decisions/active/*",
        "decisions/archive/*/*",
        "consultations/*/*/*",
        "actions/*/*/*"
      ],
      "stages": {
        "migration": "skip",
        "warning": "log",
        "soft": "confirm",
        "strict": "block"
      }
    },
    "contentLength": {
      "severity": "warning",
      "appliesTo": ["decision"],
      "minWords": 100,
      "maxWords": 10000,
      "stages": {
        "migration": "skip",
        "warning": "log",
        "soft": "confirm",
        "strict": "confirm"
      }
    }
  },
  "emergencyBypass": {
    "enabled": true,
    "requiresReason": true,
    "requiresApproval": ["admin", "strategist"],
    "auditTo": "logs/validation-bypasses.json"
  }
}
```

## 4.3 PowerShell Validation Engine

```powershell
# TacticsValidator.psm1

$Script:ValidationConfig = $null
$Script:Mode = $env:TACTICS_VALIDATION_MODE ?? "strict"

function Get-ValidationConfig {
    if ($null -eq $Script:ValidationConfig) {
        $configPath = Join-Path $PWD ".index/validation-rules.json"
        if (Test-Path $configPath) {
            $Script:ValidationConfig = Get-Content $configPath -Raw | ConvertFrom-Json -AsHashtable
        } else {
            $Script:ValidationConfig = @{ rules = @{}; defaultMode = "strict" }
        }
    }
    return $Script:ValidationConfig
}

function Test-TacticsFile {
    param(
        [Parameter(Mandatory = $true)]
        [string]$FilePath,
        
        [ValidateSet("migration", "warning", "soft", "strict")]
        [string]$Mode = $Script:Mode
    )
    
    $config = Get-ValidationConfig
    $results = @()
    $content = Get-Content $FilePath -Raw -Encoding UTF8
    $metadata = @{}
    
    # Extract metadata
    if ($content -match "^---\s*\r?\n(.*?)\r?\n---") {
        $frontmatter = $matches[1]
        $frontmatter -split "`r?\n" | ForEach-Object {
            if ($_ -match "^(\w+):\s*(.+)$") {
                $metadata[$matches[1].Trim()] = $matches[2].Trim()
            }
        }
    }
    
    # Run all rules
    foreach ($rule in $config.rules.GetEnumerator()) {
        $ruleName = $rule.Key
        $ruleConfig = $rule.Value
        
        # Check if rule applies to this mode
        if ($ruleConfig.stages[$Mode] -eq "skip") {
            continue
        }
        
        $result = Invoke-ValidationRule -RuleName $ruleName -Config $ruleConfig `
            -FilePath $FilePath -Metadata $metadata -Content $content -Mode $Mode
        
        if ($result) {
            $results += $result
        }
    }
    
    return [PSCustomObject]@{
        FilePath = $FilePath
        Mode = $Mode
        Passed = ($results | Where-Object { $_.Action -eq "block" }).Count -eq 0
        Issues = $results
        Summary = @{
            Block = ($results | Where-Object { $_.Action -eq "block" }).Count
            Confirm = ($results | Where-Object { $_.Action -eq "confirm" }).Count
            Log = ($results | Where-Object { $_.Action -eq "log" }).Count
        }
    }
}

function Invoke-ValidationRule {
    param($RuleName, $Config, $FilePath, $Metadata, $Content, $Mode)
    
    $action = $Config.stages[$Mode]
    $issues = @()
    
    switch ($RuleName) {
        "requiredHeaders" {
            foreach ($field in $Config.fields) {
                if (-not $Metadata.ContainsKey($field)) {
                    $issues += @{
                        Rule = $RuleName
                        Message = "Missing required header: $field"
                        Severity = $Config.severity
                        Action = $action
                    }
                }
            }
        }
        
        "idFormat" {
            if ($Metadata.ContainsKey("DecisionId")) {
                if ($Metadata["DecisionId"] -notmatch $Config.pattern) {
                    $issues += @{
                        Rule = $RuleName
                        Message = "Invalid ID format: $($Metadata["DecisionId"])"
                        Expected = $Config.pattern
                        Severity = $Config.severity
                        Action = $action
                    }
                }
            }
        }
        
        "contentLength" {
            $wordCount = ($Content -split "\s+").Count
            if ($wordCount -lt $Config.minWords) {
                $issues += @{
                    Rule = $RuleName
                    Message = "Content too short: $wordCount words (min: $($Config.minWords))"
                    Severity = $Config.severity
                    Action = $action
                }
            }
            if ($wordCount -gt $Config.maxWords) {
                $issues += @{
                    Rule = $RuleName
                    Message = "Content too long: $wordCount words (max: $($Config.maxWords))"
                    Severity = $Config.severity
                    Action = $action
                }
            }
        }
    }
    
    return $issues
}

function Invoke-TacticsValidation {
    param(
        [string]$Path = $PWD,
        [switch]$AutoFix,
        [switch]$CI  # Non-interactive mode
    )
    
    $files = Get-ChildItem -Path $Path -Filter "*.md" -Recurse | 
        Where-Object { $_.FullName -notlike "*/.index/*" }
    
    $allResults = @()
    $exitCode = 0
    
    foreach ($file in $files) {
        $result = Test-TacticsFile -FilePath $file.FullName
        $allResults += $result
        
        if (-not $result.Passed) {
            Write-Host "`n❌ $($file.FullName)" -ForegroundColor Red
            foreach ($issue in $result.Issues) {
                $color = switch ($issue.Action) {
                    "block" { "Red" }
                    "confirm" { "Yellow" }
                    default { "Gray" }
                }
                Write-Host "   [$($issue.Action.ToUpper())] $($issue.Message)" -ForegroundColor $color
            }
            $exitCode = 1
        } elseif ($result.Issues.Count -gt 0) {
            Write-Host "`n⚠️  $($file.FullName)" -ForegroundColor Yellow
            foreach ($issue in $result.Issues) {
                Write-Host "   [LOG] $($issue.Message)" -ForegroundColor Gray
            }
        } else {
            Write-Host "✓ $($file.FullName)" -ForegroundColor Green
        }
    }
    
    # Summary
    Write-Host "`n=== VALIDATION SUMMARY ===" -ForegroundColor Cyan
    Write-Host "Files checked: $($files.Count)"
    Write-Host "Passed: $(($allResults | Where-Object { $_.Passed }).Count)" -ForegroundColor Green
    Write-Host "Failed: $(($allResults | Where-Object { -not $_.Passed }).Count)" -ForegroundColor Red
    
    exit $exitCode
}

Export-ModuleMember -Function @('Test-TacticsFile', 'Invoke-TacticsValidation')
```

---

# PART 5: GRANULAR DECISION WORKFLOW

## 5.1 Decision Hierarchy Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     DECISION HIERARCHY                                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  LEVEL 1: STRATEGIC DECISION                                                 │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ FORGE-001: Directory Architecture Standardization                      │  │
│  │                                                                        │  │
│  │ • Broad scope, architectural impact                                    │  │
│  │ • Multiple components affected                                         │  │
│  │ • Requires Oracle consultation                                         │  │
│  │ • Approval: 90%+ Oracle rating                                         │  │
│  │                                                                        │  │
│  │ THRESHOLD TRIGGERS:                                                    │  │
│  │ • >10 files affected  OR                                               │  │
│  │ • >5 components involved  OR                                           │  │
│  │ • Est. effort > 40 hours  OR                                           │  │
│  │ • Cross-team dependencies                                              │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                   │                                          │
│                                   ▼                                          │
│  LEVEL 2: TECHNICAL DECISION                                                 │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ TECH-047: Index Rebuild Implementation Strategy                        │  │
│  │                                                                        │  │
│  │ • Component-level technical choices                                    │  │
│  │ • Derived from strategic decision                                      │  │
│  │ • Designer consultation required                                       │  │
│  │ • Approval: 85%+ Designer rating                                       │  │
│  │                                                                        │  │
│  │ THRESHOLD TRIGGERS:                                                    │  │
│  │ • 3-10 files affected  OR                                              │  │
│  │ • Single component scope  OR                                           │  │
│  │ • Est. effort 8-40 hours  OR                                           │  │
│  │ • Technical architecture change                                        │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                   │                                          │
│                                   ▼                                          │
│  LEVEL 3: COMPONENT DECISION                                                 │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ COMP-012: Validation Pipeline Stage Configuration                      │  │
│  │                                                                        │  │
│  │ • Implementation details                                               │  │
│  │ • Framework/tooling choices                                            │  │
│  │ • Designer consultation recommended                                    │  │
│  │ • Approval: 80%+ or auto-approve if pattern match                      │  │
│  │                                                                        │  │
│  │ THRESHOLD TRIGGERS:                                                    │  │
│  │ • 1-3 files affected  OR                                               │  │
│  │ • Sub-component scope  OR                                              │  │
│  │ • Est. effort 2-8 hours  OR                                            │  │
│  │ • Standard pattern application                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                   │                                          │
│                                   ▼                                          │
│  LEVEL 4: IMPLEMENTATION DECISION                                            │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ IMPL-156: PowerShell Module Error Handling Approach                    │  │
│  │                                                                        │  │
│  │ • Code-level choices                                                   │  │
│  │ • Refactoring decisions                                                │  │
│  │ • Auto-approved if follows established patterns                        │  │
│  │ • Logged for audit trail                                               │  │
│  │                                                                        │  │
│  │ THRESHOLD TRIGGERS:                                                    │  │
│  │ • 1 file affected  OR                                                  │  │
│  │ • < 2 hours effort  OR                                                 │  │
│  │ • Bug fix or minor enhancement                                         │  │
│  │ • Pattern-based implementation                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

## 5.2 Workflow State Machine

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DECISION STATE MACHINE                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                         ┌──────────┐                                        │
│                    ┌────│  DRAFT   │◄────────────────┐                     │
│                    │    └────┬─────┘                 │                     │
│                    │         │ Initiated              │                     │
│                    │         ▼                        │                     │
│                    │   ┌──────────┐                   │                     │
│                    │   │ PROPOSED │◄──────────┐       │                     │
│                    │   └────┬─────┘           │       │                     │
│                    │        │ Needs           │       │                     │
│                    │        │ Consultation    │       │                     │
│                    │        ▼                 │       │                     │
│                    │  ┌──────────────┐       │       │                     │
│                    │  │ CONSULTATION │───────┘       │                     │
│                    │  └──────┬───────┘   Changes     │                     │
│                    │         │ Requested              │                     │
│                    │         ▼                        │                     │
│                    │   ┌──────────┐                   │                     │
│                    │   │ REVISION │───────────────────┘                     │
│                    │   └────┬─────┘                                        │
│                    │        │ Approved                                      │
│                    │        ▼                                               │
│                    │  ┌──────────┐                                          │
│                    └──┤ APPROVED │◄────────────────────────┐                │
│                       └────┬─────┘                         │                │
│                            │ Implementation               │                │
│                            ▼ Complete                      │                │
│                       ┌──────────┐                         │                │
│                       │COMPLETE  │─────────────────────────┘                │
│                       └────┬─────┘   Rollback                              │
│                            │                                               │
│                            ▼                                               │
│                       ┌──────────┐                                         │
│                       │  CLOSED  │                                         │
│                       └──────────┘                                         │
│                                                                             │
│  REJECT PATH:                                                               │
│  ┌──────────┐      ┌──────────┐                                             │
│  │ PROPOSED │─────►│ REJECTED │                                             │
│  └──────────┘      └──────────┘                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 5.3 Decision Router Logic

```powershell
# DecisionRouter.ps1
function Get-DecisionLevel {
    param(
        [string]$Description,
        [string[]]$FilesAffected,
        [string[]]$Components,
        [int]$EstimatedHours,
        [bool]$CrossTeam = $false
    )
    
    $score = 0
    
    # File count scoring
    $score += switch ($FilesAffected.Count) {
        { $_ -gt 10 } { 40 }
        { $_ -gt 5 }  { 30 }
        { $_ -gt 2 }  { 20 }
        default       { 10 }
    }
    
    # Component count scoring
    $score += $Components.Count * 8
    
    # Effort scoring
    $score += switch ($EstimatedHours) {
        { $_ -gt 40 } { 30 }
        { $_ -gt 20 } { 20 }
        { $_ -gt 8 }  { 15 }
        { $_ -gt 2 }  { 10 }
        default       { 5 }
    }
    
    # Cross-team multiplier
    if ($CrossTeam) { $score += 15 }
    
    # Determine level
    return switch ($score) {
        { $_ -ge 60 } { 
            [PSCustomObject]@{
                Level = "STRATEGIC"
                Prefix = "FORGE"
                RequiredConsultation = "Oracle"
                MinApproval = 90
                Score = $score
            }
        }
        { $_ -ge 40 } {
            [PSCustomObject]@{
                Level = "TECHNICAL"
                Prefix = "TECH"
                RequiredConsultation = "Designer"
                MinApproval = 85
                Score = $score
            }
        }
        { $_ -ge 25 } {
            [PSCustomObject]@{
                Level = "COMPONENT"
                Prefix = "COMP"
                RequiredConsultation = "Designer"  # Optional
                MinApproval = 80
                Score = $score
            }
        }
        default {
            [PSCustomObject]@{
                Level = "IMPLEMENTATION"
                Prefix = "IMPL"
                RequiredConsultation = $null
                MinApproval = 0  # Auto-approve
                Score = $score
            }
        }
    }
}

# Example usage
$level = Get-DecisionLevel `
    -Description "Add validation pipeline" `
    -FilesAffected @("validator.ps1", "rules.json") `
    -Components @("validation") `
    -EstimatedHours 12

Write-Host "Decision Level: $($level.Level)" -ForegroundColor Cyan
Write-Host "ID Prefix: $($level.Prefix)" -ForegroundColor Cyan
Write-Host "Required Consultation: $($level.RequiredConsultation)" -ForegroundColor Cyan
```

---

# PART 6: ENHANCED DECISION TEMPLATES

## 6.1 Expanded DECISION-TEMPLATE.md

```markdown
# DECISION TEMPLATE v2.0

## Header (REQUIRED)
```yaml
---
DecisionId: [PREFIX]-[NUMBER]      # e.g., FORGE-001, TECH-047
Title: [Clear, descriptive title]
Status: proposed                    # proposed | consultation | revision | approved | complete | closed
Level: strategic                    # strategic | technical | component | implementation
Author: [Name]
Created: YYYY-MM-DDTHH:MM:SS
ConsultationRequired: [agent-name]  # e.g., Oracle, Designer
TargetApproval: 90                  # Percentage rating required
---
```

## 1. EXECUTIVE SUMMARY (REQUIRED)
<!-- 2-3 sentences describing what this decision addresses and why it matters -->

## 2. CONTEXT & MOTIVATION (REQUIRED)
### 2.1 Background
<!-- What led to this decision? What problem are we solving? -->

### 2.2 Current State
<!-- Describe the current situation that necessitates change -->

### 2.3 Constraints
<!-- Technical, organizational, or time constraints -->

## 3. REQUIREMENTS (REQUIRED)
### 3.1 Functional Requirements
| ID | Requirement | Priority | Acceptance Criteria |
|----|-------------|----------|---------------------|
| FR-1 | [Description] | Must/Should/Could/Wont | [Measurable criteria] |

### 3.2 Non-Functional Requirements
| ID | Category | Requirement | Target |
|----|----------|-------------|--------|
| NFR-1 | Performance | [Description] | [Metric] |
| NFR-2 | Reliability | [Description] | [Metric] |
| NFR-3 | Security | [Description] | [Standard] |
| NFR-4 | Maintainability | [Description] | [Metric] |

## 4. OPTIONS CONSIDERED (REQUIRED)
### Option A: [Name]
**Description:**
**Pros:**
- 
**Cons:**
- 
**Effort Estimate:**
**Risk Level:** Low/Medium/High

### Option B: [Name]
[Same structure]

### Option C: [Name]
[Same structure]

## 5. DECISION (REQUIRED)
**Selected Option:** [A/B/C/Other]

**Rationale:**
<!-- Why was this option selected? -->

**Trade-offs Accepted:**
<!-- What are we giving up by choosing this? -->

## 6. ARCHITECTURE (REQUIRED for Level ≥ Technical)
### 6.1 System Diagram
```
[ASCII or reference to external diagram]
```

### 6.2 Components
| Component | Responsibility | Technology | Owner |
|-----------|---------------|------------|-------|
| [Name] | [Description] | [Stack] | [Team/Agent] |

### 6.3 Interfaces
| Interface | Protocol | Contract |
|-----------|----------|----------|
| [Name] | [REST/gRPC/etc] | [Link to spec] |

### 6.4 Data Model
```
[Entity relationships or schema]
```

## 7. IMPLEMENTATION PLAN (REQUIRED)
### 7.1 Phases
| Phase | Description | Duration | Dependencies | Success Criteria |
|-------|-------------|----------|--------------|------------------|
| 1 | [Description] | X days | [List] | [Criteria] |
| 2 | [Description] | X days | [List] | [Criteria] |

### 7.2 Tasks
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

### 7.3 Resource Requirements
- **Personnel:** [Who is needed]
- **Tools:** [Software/licenses]
- **Infrastructure:** [Compute/storage]
- **Budget:** [If applicable]

## 8. TESTING STRATEGY (REQUIRED)
### 8.1 Test Levels
| Level | Type | Coverage Target | Automation |
|-------|------|-----------------|------------|
| Unit | [Description] | X% | Yes/No |
| Integration | [Description] | X% | Yes/No |
| E2E | [Description] | X% | Yes/No |

### 8.2 Test Cases
| ID | Scenario | Expected Result | Priority |
|----|----------|-----------------|----------|
| TC-1 | [Description] | [Result] | High/Med/Low |

### 8.3 Test Data
<!-- Requirements for test data, fixtures, or mock services -->

## 9. DEPLOYMENT PLAN (REQUIRED for Level ≥ Component)
### 9.1 Deployment Strategy
- [ ] Blue/Green
- [ ] Canary
- [ ] Rolling
- [ ] Big Bang

### 9.2 Rollback Criteria
<!-- What triggers an automatic or manual rollback? -->

### 9.3 Rollback Procedure
1. Step 1
2. Step 2
3. Step 3

### 9.4 Feature Flags
| Flag | Description | Default | Removal Target |
|------|-------------|---------|----------------|
| [name] | [Description] | true/false | [Date/Condition] |

## 10. OPERATIONS (REQUIRED for Level ≥ Technical)
### 10.1 Monitoring
| Metric | Target | Alert Threshold | Dashboard |
|--------|--------|-----------------|-----------|
| [Name] | [Value] | [Condition] | [Link] |

### 10.2 Alerting
| Condition | Severity | Response | Escalation |
|-----------|----------|----------|------------|
| [Description] | P1/P2/P3 | [Action] | [Who] |

### 10.3 Runbooks
- [Link to operational runbooks]

### 10.4 Maintenance Schedule
- **Regular:** [Frequency and tasks]
- **Emergency:** [Contact and procedures]

## 11. RISK ANALYSIS (REQUIRED)
| Risk | Likelihood | Impact | Mitigation | Owner |
|------|------------|--------|------------|-------|
| [Description] | High/Med/Low | High/Med/Low | [Strategy] | [Name] |

## 12. DEPENDENCIES (REQUIRED)
### 12.1 Depends On
- [Decision ID]: [Description of dependency]

### 12.2 Required By
- [Decision ID]: [Description]

## 13. CONTINUOUS IMPROVEMENT (REQUIRED)
### 13.1 Success Metrics
| Metric | Baseline | Target | Measurement |
|--------|----------|--------|-------------|
| [Name] | [Value] | [Value] | [Method] |

### 13.2 Review Schedule
- **Initial Review:** [Date, 1 week after completion]
- **Quarterly Review:** [Date pattern]
- **Annual Review:** [Date pattern]

### 13.3 Feedback Collection
- Method: [Survey/Interview/Metrics]
- Stakeholders: [Who]
- Action Threshold: [When to trigger improvement]

## 14. APPROVAL TRACKING
| Role | Name | Rating | Date | Notes |
|------|------|--------|------|-------|
| Strategist | | | | |
| Oracle | | | | |
| Designer | | | | |
| Implementer | | | | |

## 15. CHANGE LOG
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| YYYY-MM-DD | 1.0 | [Name] | Initial version |

---

## Quick Reference: Level-Specific Requirements

| Section | Strategic | Technical | Component | Implementation |
|---------|-----------|-----------|-----------|----------------|
| Executive Summary | Required | Required | Required | Required |
| Context | Required | Required | Required | Condensed |
| Requirements | Full | Full | Partial | Key only |
| Options | 3+ options | 2-3 options | 2 options | 1-2 options |
| Architecture | Full diagram | Component list | Brief | Optional |
| Implementation | Phased plan | Phased plan | Task list | Task list |
| Testing | Full strategy | Test plan | Key tests | Basic tests |
| Deployment | Full plan | Full plan | Basic plan | Optional |
| Operations | Full section | Monitoring | Monitoring | None |
| Risk Analysis | Full matrix | Key risks | Key risks | Optional |
| Dependencies | All levels | Related decisions | Related decisions | Immediate |
| Improvement | Full loop | Metrics | Metrics | Optional |
```

## 6.2 Template Validator

```powershell
# Validates that a decision file follows the template
function Test-DecisionTemplate {
    param([string]$FilePath)
    
    $content = Get-Content $FilePath -Raw
    $issues = @()
    
    # Required sections check
    $requiredSections = @(
        "## 1. EXECUTIVE SUMMARY",
        "## 2. CONTEXT",
        "## 3. REQUIREMENTS",
        "## 4. OPTIONS CONSIDERED",
        "## 5. DECISION"
    )
    
    foreach ($section in $requiredSections) {
        if ($content -notmatch [regex]::Escape($section)) {
            $issues += "Missing required section: $section"
        }
    }
    
    # Check for empty sections
    $sectionPattern = '(?ms)^## \d+\. .+?\n(.*?)(?=^## |\Z)'
    [regex]::Matches($content, $sectionPattern) | ForEach-Object {
        $sectionContent = $_.Groups[1].Value.Trim()
        $sectionHeader = ($_.Value -split "\n")[0]
        if ($sectionContent -eq "" -or $sectionContent -match "^<!--.*?-->$") {
            $issues += "Empty section: $sectionHeader"
        }
    }
    
    # Level-appropriate checks
    if ($content -match 'Level:\s*(strategic|technical)') {
        $advancedSections = @("## 9. DEPLOYMENT", "## 10. OPERATIONS")
        foreach ($section in $advancedSections) {
            if ($content -notmatch [regex]::Escape($section)) {
                $issues += "Level requires section: $section"
            }
        }
    }
    
    return [PSCustomObject]@{
        FilePath = $FilePath
        Compliant = $issues.Count -eq 0
        Issues = $issues
    }
}
```

---

# PART 7: COMPREHENSIVE TESTING STRATEGY

## 7.1 Testing Pyramid for Decisions

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      DECISION TESTING PYRAMID                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                              ┌─────────────┐                               │
│                              │             │                               │
│                              │   E2E       │  Decision Workflow Tests      │
│                              │   Tests     │  - Full lifecycle simulation  │
│                              │   (5%)      │  - Cross-agent handoffs       │
│                              │             │  - Approval chain             │
│                              └──────┬──────┘                               │
│                                     │                                       │
│                            ┌────────┴────────┐                             │
│                            │                 │                             │
│                            │  Integration    │  Cross-Reference Tests      │
│                            │  Tests          │  - Index rebuild + query    │
│                            │  (15%)          │  - ID allocation + usage    │
│                            │                 │  - Path resolution          │
│                            └────────┬────────┘                             │
│                                     │                                       │
│                         ┌───────────┴───────────┐                         │
│                         │                       │                         │
│                         │    Unit Tests         │  Component Tests         │
│                         │    (80%)              │  - Template validation    │
│                         │                       │  - Rule engine            │
│                         │                       │  - File parser            │
│                         └───────────────────────┘                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 7.2 Test Categories and Implementation

### Category 1: Structure Tests

```powershell
# Tests/Structure.Tests.ps1
Describe "TACTICS Directory Structure" {
    BeforeAll {
        $TacticsRoot = "$PSScriptRoot/../T4CT1CS"
    }
    
    It "Has required root directories" {
        @("decisions", "consultations", "actions", ".index") | ForEach-Object {
            "$TacticsRoot/$_" | Should -Exist
        }
    }
    
    It "Has required index files after rebuild" {
        Invoke-Expression "$TacticsRoot/scripts/Rebuild-TacticsIndex.ps1"
        @("tactics-index.json", "health.json", "decisions.json") | ForEach-Object {
            "$TacticsRoot/.index/$_" | Should -Exist
        }
    }
    
    It "All decision files follow naming convention" {
        $files = Get-ChildItem "$TacticsRoot/decisions" -Filter "*.md" -Recurse
        $files | ForEach-Object {
            $_.Name | Should -Match "^[A-Z]+-\d+.*\.md$"
        }
    }
}
```

### Category 2: Content Tests

```powershell
# Tests/Content.Tests.ps1
Describe "Decision File Content" {
    BeforeAll {
        $decisionFiles = Get-ChildItem "$PSScriptRoot/../T4CT1CS/decisions" -Filter "*.md" -Recurse
    }
    
    It "All decisions have required YAML frontmatter" -ForEach $decisionFiles {
        $content = Get-Content $_.FullName -Raw
        $content | Should -Match "^---\s*\r?\n"
        $content | Should -Match "DecisionId:\s*[A-Z]+-\d+"
        $content | Should -Match "Status:\s*(proposed|consultation|approved|complete)"
    }
    
    It "DecisionId matches filename" -ForEach $decisionFiles {
        $content = Get-Content $_.FullName -Raw
        if ($content -match "DecisionId:\s*([A-Z]+-\d+)") {
            $id = $matches[1]
            $_.BaseName | Should -Match $id
        }
    }
    
    It "All required sections present" -ForEach $decisionFiles {
        $content = Get-Content $_.FullName -Raw
        @("EXECUTIVE SUMMARY", "CONTEXT", "REQUIREMENTS", "DECISION") | ForEach-Object {
            $content | Should -Match "## .*$_"
        }
    }
}
```

### Category 3: Integration Tests

```powershell
# Tests/Integration.Tests.ps1
Describe "Cross-Reference Integrity" {
    BeforeAll {
        $index = Get-Content "$PSScriptRoot/../T4CT1CS/.index/tactics-index.json" | ConvertFrom-Json
    }
    
    It "All cross-references point to existing files" {
        $brokenRefs = $index.CrossReferences | Where-Object {
            -not ($index.IdRegistry.ContainsKey($_.Target))
        }
        $brokenRefs | Should -BeNullOrEmpty
    }
    
    It "All IDs in registry have corresponding files" {
        $orphanedIds = $index.IdRegistry.GetEnumerator() | Where-Object {
            -not (Test-Path "$PSScriptRoot/../T4CT1CS/$($_.Value)")
        }
        $orphanedIds | Should -BeNullOrEmpty
    }
    
    It "Index health status is not CRITICAL" {
        $health = Get-Content "$PSScriptRoot/../T4CT1CS/.index/health.json" | ConvertFrom-Json
        $health.Status | Should -Not -Be "CRITICAL"
    }
}

Describe "ID Allocation System" {
    BeforeAll {
        Import-Module "$PSScriptRoot/../T4CT1CS/scripts/TacticsIdAllocator.psm1" -Force
    }
    
    It "Can allocate unique IDs" {
        $ids1 = New-TacticsId -Prefix "TEST" -Count 3
        $ids2 = New-TacticsId -Prefix "TEST" -Count 3
        
        # Check uniqueness within batch
        ($ids1 | Select-Object -Unique).Count | Should -Be 3
        
        # Check sequential
        [int]($ids1[0] -replace "TEST-", "") + 1 | Should -Be ([int]($ids1[1] -replace "TEST-", ""))
        
        # Check no overlap between batches
        $intersection = $ids1 | Where-Object { $ids2 -contains $_ }
        $intersection | Should -BeNullOrEmpty
    }
    
    It "Can reserve and claim IDs" {
        $reserved = New-TacticsId -Prefix "TEST" -Count 2 -Reserve -ReserveFor "test-session"
        $reserved.Count | Should -Be 2
        
        $status = $reserved | Get-TacticsIdStatus
        $status | ForEach-Object { $_.Status | Should -Be "reserved" }
        
        $reserved | ForEach-Object { Confirm-TacticsIdReservation -Id $_ }
        
        $status = $reserved | Get-TacticsIdStatus
        $status | ForEach-Object { $_.Status | Should -Be "active" }
    }
}
```

### Category 4: Functional Tests

```powershell
# Tests/Functional.Tests.ps1
Describe "Decision Workflow" {
    It "Complete lifecycle: propose → consult → approve → complete" {
        # Arrange
        $testDecision = @{
            DecisionId = "TEST-999"
            Title = "Test Decision"
            Status = "proposed"
        }
        
        # Act - Propose
        $testDecision | Export-Clixml "$TestDrive/decision.xml"
        $testDecision.Status | Should -Be "proposed"
        
        # Act - Move to consultation
        $testDecision.Status = "consultation"
        $testDecision.Status | Should -Be "consultation"
        
        # Act - Receive approval
        $testDecision.Status = "approved"
        $testDecision.ApprovalRating = 95
        $testDecision.Status | Should -Be "approved"
        $testDecision.ApprovalRating | Should -BeGreaterOrEqual 90
        
        # Act - Complete
        $testDecision.Status = "complete"
        $testDecision.CompletedAt = Get-Date -Format "o"
        $testDecision.Status | Should -Be "complete"
    }
    
    It "Index rebuild produces consistent results" {
        $index1 = Invoke-Expression "$PSScriptRoot/../T4CT1CS/scripts/Rebuild-TacticsIndex.ps1 -DryRun"
        $index2 = Invoke-Expression "$PSScriptRoot/../T4CT1CS/scripts/Rebuild-TacticsIndex.ps1 -DryRun"
        
        $index1.Statistics.TotalFiles | Should -Be $index2.Statistics.TotalFiles
        $index1.Health.Status | Should -Be $index2.Health.Status
    }
}
```

## 7.3 Test Automation Strategy

```yaml
# .github/workflows/tactics-tests.yml
name: TACTICS Test Suite

on:
  push:
    paths:
      - 'T4CT1CS/**'
  pull_request:
    paths:
      - 'T4CT1CS/**'
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours

jobs:
  structure-tests:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Structure Tests
        run: |
          Invoke-Pester -Path "T4CT1CS/Tests/Structure.Tests.ps1" -OutputFormat NUnitXml -OutputFile structure-tests.xml
      - name: Publish Results
        uses: actions/upload-artifact@v4
        with:
          name: structure-test-results
          path: structure-tests.xml

  content-tests:
    runs-on: windows-latest
    needs: structure-tests
    steps:
      - uses: actions/checkout@v4
      - name: Run Content Tests
        run: |
          Invoke-Pester -Path "T4CT1CS/Tests/Content.Tests.ps1" -OutputFormat NUnitXml -OutputFile content-tests.xml

  integration-tests:
    runs-on: windows-latest
    needs: [structure-tests, content-tests]
    steps:
      - uses: actions/checkout@v4
      - name: Setup Environment
        run: |
          .\T4CT1CS\scripts\Rebuild-TacticsIndex.ps1
      - name: Run Integration Tests
        run: |
          Invoke-Pester -Path "T4CT1CS/Tests/Integration.Tests.ps1" -OutputFormat NUnitXml

  functional-tests:
    runs-on: windows-latest
    needs: integration-tests
    steps:
      - uses: actions/checkout@v4
      - name: Run Functional Tests
        run: |
          Invoke-Pester -Path "T4CT1CS/Tests/Functional.Tests.ps1" -OutputFormat NUnitXml

  test-summary:
    runs-on: windows-latest
    needs: [structure-tests, content-tests, integration-tests, functional-tests]
    if: always()
    steps:
      - name: Check All Tests Passed
        run: |
          $results = @(${{ toJSON(needs.*.result) }})
          $failed = $results | Where-Object { $_ -ne "success" }
          if ($failed) {
            Write-Error "Some tests failed"
            exit 1
          }
```

## 7.4 Test Fixtures and Mock Data

```powershell
# Tests/Fixtures/Generate-TestData.ps1
function New-TestDecision {
    param(
        [string]$Id,
        [string]$Status = "proposed",
        [int]$ApprovalRating = 0
    )
    
    return @"
---
DecisionId: $Id
Title: Test Decision $Id
Status: $Status
Level: component
Author: Test Generator
Created: $(Get-Date -Format "o")
$(if ($ApprovalRating -gt 0) { "ApprovalRating: $ApprovalRating" })
---

## 1. EXECUTIVE SUMMARY
Test decision for automated testing purposes.

## 2. CONTEXT
This is a generated test fixture.

## 3. REQUIREMENTS
- Must be testable
- Must be consistent

## 4. OPTIONS CONSIDERED
### Option A: Test Approach
Pros: Reliable
Cons: None

## 5. DECISION
**Selected:** Option A

## 6. IMPLEMENTATION PLAN
- [ ] Step 1
- [ ] Step 2
"@
}

# Generate test fixtures
$testDecisions = @("TEST-001", "TEST-002", "TEST-003")
foreach ($id in $testDecisions) {
    $content = New-TestDecision -Id $id
    $content | Set-Content -Path "$PSScriptRoot/../../.test-data/decisions/active/$id.md"
}
```

---

# PART 8: DEPLOYMENT AND ROLLBACK STRATEGY

## 8.1 Deployment Phases with Gates

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DEPLOYMENT PHASE GATES                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  PHASE 0: PREPARATION                                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Validate all files pass structure tests                           │   │
│  │ • Run full index rebuild                                            │   │
│  │ • Verify health status = HEALTHY                                    │   │
│  │ • Create deployment tag                                             │   │
│  │                                                                     │   │
│  │ GATE: All tests must pass                                           │   │
│  │ OWNER: CI/CD Pipeline                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  PHASE 1: VALIDATION MODE                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Set TACTICS_VALIDATION_MODE=warning                               │   │
│  │ • Deploy to single workstation (pilot)                              │   │
│  │ • Monitor for 24 hours                                              │   │
│  │ • Collect warnings and feedback                                     │   │
│  │                                                                     │   │
│  │ GATE: Warning count < 10 AND no blocking issues                     │   │
│  │ OWNER: Strategist                                                   │   │
│  │ ROLLBACK TRIGGER: >20 warnings OR critical error                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  PHASE 2: SOFT ENFORCEMENT                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Set TACTICS_VALIDATION_MODE=soft                                  │   │
│  │ • Deploy to team leads (5 users)                                    │   │
│  │ • Monitor for 48 hours                                              │   │
│  │ • Track override frequency                                          │   │
│  │                                                                     │   │
│  │ GATE: Override rate < 5% AND positive feedback                      │   │
│  │ OWNER: Designer + Strategist                                        │   │
│  │ ROLLBACK TRIGGER: Override rate > 15% OR negative feedback         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  PHASE 3: STRICT MODE (PRODUCTION)                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Set TACTICS_VALIDATION_MODE=strict                                │   │
│  │ • Deploy to all agents                                              │   │
│  │ • Enable all automated checks                                       │   │
│  │ • Monitor health metrics                                            │   │
│  │                                                                     │   │
│  │ GATE: Zero critical errors for 72 hours                             │   │
│  │ OWNER: Oracle                                                       │   │
│  │ ROLLBACK TRIGGER: Critical error OR health status downgrade         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  PHASE 4: OPTIMIZATION                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Review metrics and feedback                                       │   │
│  │ • Identify improvement opportunities                                │   │
│  │ • Create improvement decisions                                      │   │
│  │ • Archive deployment documentation                                  │   │
│  │                                                                     │   │
│  │ GATE: Continuous improvement loop active                            │   │
│  │ OWNER: All agents                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 8.2 Rollback Procedures

### Automated Rollback (Triggers)

```powershell
# Rollback-DecisionDeployment.ps1
[CmdletBinding()]
param(
    [Parameter(Mandatory = $true)]
    [string]$DecisionId,
    
    [ValidateSet("automatic", "manual")]
    [string]$Type = "manual",
    
    [string]$Reason,
    [switch]$Force
)

$rollbackStartTime = Get-Date

Write-Host "=== ROLLBACK INITIATED ===" -ForegroundColor Red
Write-Host "Decision: $DecisionId" -ForegroundColor Yellow
Write-Host "Type: $Type" -ForegroundColor Yellow
Write-Host "Reason: $Reason" -ForegroundColor Yellow
Write-Host "Time: $($rollbackStartTime.ToString('o'))" -ForegroundColor Yellow

# 1. Verify rollback is authorized
if ($Type -eq "manual" -and -not $Force) {
    $confirmation = Read-Host "Are you sure you want to rollback $DecisionId? (yes/no)"
    if ($confirmation -ne "yes") {
        Write-Host "Rollback cancelled" -ForegroundColor Green
        exit 0
    }
}

# 2. Create rollback audit entry
$rollbackLog = @{
    DecisionId = $DecisionId
    Timestamp = $rollbackStartTime.ToString("o")
    Type = $Type
    Reason = $Reason
    InitiatedBy = $env:USERNAME
    Steps = @()
}

# 3. Retrieve deployment state
$deploymentState = Get-Content ".index/deployments/$DecisionId-state.json" | ConvertFrom-Json

# 4. Execute rollback steps
try {
    # Step 1: Restore validation mode
    if ($deploymentState.PreviousValidationMode) {
        [Environment]::SetEnvironmentVariable(
            "TACTICS_VALIDATION_MODE", 
            $deploymentState.PreviousValidationMode,
            "Process"
        )
        $rollbackLog.Steps += @{ Step = 1; Action = "Restore validation mode"; Status = "Success" }
    }
    
    # Step 2: Restore index backup
    if ($deploymentState.IndexBackupPath -and (Test-Path $deploymentState.IndexBackupPath)) {
        $indexDir = ".index"
        Remove-Item -Path "$indexDir/*" -Exclude ".backups", ".checkpoints" -Recurse -Force
        Copy-Item -Path "$($deploymentState.IndexBackupPath)/*" -Destination $indexDir -Recurse -Force
        $rollbackLog.Steps += @{ Step = 2; Action = "Restore index from backup"; Status = "Success" }
    }
    
    # Step 3: Restore ID registry if modified
    if ($deploymentState.IdRegistryBackupPath -and (Test-Path $deploymentState.IdRegistryBackupPath)) {
        Copy-Item -Path $deploymentState.IdRegistryBackupPath -Destination ".index/id-registry.json" -Force
        $rollbackLog.Steps += @{ Step = 3; Action = "Restore ID registry"; Status = "Success" }
    }
    
    # Step 4: Revert file moves
    foreach ($move in $deploymentState.FileMoves) {
        if (Test-Path $move.NewPath) {
            # Reverse the move
            $destDir = Split-Path $move.OriginalPath -Parent
            if (-not (Test-Path $destDir)) {
                New-Item -ItemType Directory -Path $destDir -Force | Out-Null
            }
            Move-Item -Path $move.NewPath -Destination $move.OriginalPath -Force
        }
    }
    $rollbackLog.Steps += @{ Step = 4; Action = "Revert file moves"; Status = "Success" }
    
    # Step 5: Update decision status
    $decisionPath = Resolve-TacticsPath -Path "$DecisionId.md"
    if ($decisionPath.ResolvedPath) {
        $content = Get-Content $decisionPath.ResolvedPath -Raw
        $content = $content -replace "Status:\s*\w+", "Status: rolled-back"
        $content += "`n`n## ROLLBACK RECORD`n**Date:** $($rollbackStartTime.ToString('o'))`n**Reason:** $Reason`n"
        Set-Content -Path $decisionPath.ResolvedPath -Value $content
    }
    $rollbackLog.Steps += @{ Step = 5; Action = "Update decision status"; Status = "Success" }
    
    $rollbackLog.Success = $true
    $rollbackLog.Duration = ([datetime]::UtcNow - $rollbackStartTime).ToString()
    
    Write-Host "`n=== ROLLBACK COMPLETED SUCCESSFULLY ===" -ForegroundColor Green
    Write-Host "Duration: $($rollbackLog.Duration)" -ForegroundColor Cyan
    
} catch {
    $rollbackLog.Success = $false
    $rollbackLog.Error = $_.Exception.Message
    Write-Host "`n=== ROLLBACK FAILED ===" -ForegroundColor Red
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    throw
} finally {
    # Save rollback log
    $logPath = ".index/rollbacks/$DecisionId-$($rollbackStartTime.ToString('yyyyMMdd-HHmmss')).json"
    $rollbackLog | ConvertTo-Json -Depth 10 | Set-Content -Path $logPath
    Write-Host "Rollback log saved to: $logPath" -ForegroundColor Gray
}
```

## 8.3 Feature Flags Configuration

```json
{
  "version": "1.0.0",
  "flags": {
    "indexAutoRebuild": {
      "description": "Automatically rebuild index on file changes",
      "enabled": true,
      "targets": ["all"],
      "rolloutPercentage": 100
    },
    "validationPipeline": {
      "description": "Enable staged validation pipeline",
      "enabled": true,
      "targets": ["all"],
      "mode": "soft",
      "rolloutPercentage": 25
    },
    "idAllocation": {
      "description": "Use centralized ID allocator",
      "enabled": true,
      "targets": ["strategist", "windsurf"],
      "rolloutPercentage": 100
    },
    "pathResolution": {
      "description": "Enable path alias resolution",
      "enabled": true,
      "targets": ["all"],
      "rolloutPercentage": 100
    },
    "granularDecisions": {
      "description": "Enable hierarchical decision workflow",
      "enabled": false,
      "targets": ["strategist"],
      "rolloutPercentage": 0
    }
  }
}
```

---

# PART 9: MONITORING AND OBSERVABILITY

## 9.1 Metrics Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    OBSERVABILITY STACK                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        DATA COLLECTION                               │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐            │   │
│  │  │ File     │  │ Decision │  │ Agent    │  │ System   │            │   │
│  │  │ Events   │  │ Events   │  │ Activity │  │ Health   │            │   │
│  │  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘            │   │
│  │       │             │             │             │                   │   │
│  │       └─────────────┴─────────────┴─────────────┘                   │   │
│  │                         │                                           │   │
│  │                         ▼                                           │   │
│  │              ┌────────────────────┐                                 │   │
│  │              │  Event Store       │                                 │   │
│  │              │  (.index/metrics/) │                                 │   │
│  │              └────────┬───────────┘                                 │   │
│  └───────────────────────┼─────────────────────────────────────────────┘   │
│                          │                                                 │
│                          ▼                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     METRICS AGGREGATION                              │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────────┐ │   │
│  │  │ Counter     │  │ Gauge       │  │ Histogram                   │ │   │
│  │  │ (totals)    │  │ (current)   │  │ (distributions)             │ │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                          │                                                 │
│                          ▼                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    ALERTING & DASHBOARDS                             │   │
│  │  ┌──────────┐      ┌──────────┐      ┌──────────┐                  │   │
│  │  │ Alerts   │      │ Dashboard│      │ Reports  │                  │   │
│  │  │ (realtime)      │ (visual) │      │ (periodic)                  │   │
│  │  └──────────┘      └──────────┘      └──────────┘                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 9.2 Key Metrics Specification

```json
{
  "metrics": {
    "decisionLifecycle": {
      "decisionCreationRate": {
        "type": "counter",
        "description": "Decisions created per day",
        "labels": ["level", "author"],
        "alertThreshold": { "min": 1, "max": 50 }
      },
      "decisionCompletionRate": {
        "type": "gauge", 
        "description": "Percentage of decisions completed within SLA",
        "alertThreshold": { "min": 0.7 }
      },
      "timeToApproval": {
        "type": "histogram",
        "description": "Days from proposal to approval",
        "buckets": [1, 3, 7, 14, 30]
      }
    },
    "systemHealth": {
      "indexConsistencyScore": {
        "type": "gauge",
        "description": "Percentage of valid cross-references",
        "alertThreshold": { "min": 0.95 }
      },
      "validationErrorRate": {
        "type": "gauge",
        "description": "Errors per 100 validations",
        "alertThreshold": { "max": 5 }
      },
      "rebuildDuration": {
        "type": "histogram",
        "description": "Index rebuild time in seconds",
        "alertThreshold": { "max": 300 }
      }
    },
    "agentActivity": {
      "consultationRequestRate": {
        "type": "counter",
        "description": "Consultation requests per day",
        "labels": ["agent", "type"]
      },
      "approvalRatingDistribution": {
        "type": "histogram",
        "description": "Distribution of approval ratings",
        "buckets": [60, 70, 80, 90, 95, 100]
      },
      "agentConfusionIncidents": {
        "type": "counter",
        "description": "Agent requests for clarification",
        "alertThreshold": { "max": 5 }
      }
    }
  }
}
```

## 9.3 Dashboard Specification

```powershell
# New-TacticsDashboard.ps1
function New-TacticsDashboard {
    $dashboard = @{
        title = "TACTICS System Health"
        refresh = "30s"
        panels = @(
            @{
                title = "System Health Status"
                type = "stat"
                targets = @(@{ expr = "tactics_health_status" })
                thresholds = @(
                    @{ color = "green"; value = 0 },
                    @{ color = "yellow"; value = 1 },
                    @{ color = "red"; value = 2 }
                )
            },
            @{
                title = "Index Consistency"
                type = "gauge"
                targets = @(@{ expr = "tactics_index_consistency" })
                fieldConfig = @{
                    min = 0
                    max = 100
                    thresholds = @(
                        @{ color = "red"; value = 0 },
                        @{ color = "yellow"; value = 90 },
                        @{ color = "green"; value = 95 }
                    )
                }
            },
            @{
                title = "Decision Velocity"
                type = "graph"
                targets = @(
                    @{ expr = "rate(tactics_decisions_created_total[1d])"; legend = "Created" },
                    @{ expr = "rate(tactics_decisions_completed_total[1d])"; legend = "Completed" }
                )
            },
            @{
                title = "Validation Errors"
                type = "table"
                targets = @(@{ 
                    expr = "tactics_validation_errors"
                    format = "table"
                })
                columns = @("File", "Error Type", "Severity", "Time")
            },
            @{
                title = "Agent Activity"
                type = "heatmap"
                targets = @(@{ expr = "tactics_agent_activity_bucket" })
                dataFormat = "tsbuckets"
            },
            @{
                title = "Approval Ratings Trend"
                type = "graph"
                targets = @(
                    @{ expr = "avg(tactics_approval_rating) by (decision_level)" }
                )
            }
        )
    }
    
    $dashboard | ConvertTo-Json -Depth 10 | Set-Content -Path ".index/dashboard.json"
    return $dashboard
}
```

## 9.4 Alert Configuration

```yaml
# .index/alerts.yml
alerts:
  - name: IndexCorruptionDetected
    condition: tactics_health_status == 2  # CRITICAL
    severity: p1
    channels: [slack, email]
    message: "TACTICS index is in CRITICAL state. Immediate attention required."
    autoCreateIncident: true
    runbook: "https://wiki/runbooks/index-corruption"
    
  - name: HighValidationErrorRate  
    condition: tactics_validation_error_rate > 0.1
    severity: p2
    channels: [slack]
    message: "Validation error rate is {{ $value }}%, exceeding 10% threshold"
    duration: "5m"
    
  - name: DecisionCompletionRateLow
    condition: tactics_decision_completion_rate < 0.7
    severity: p3
    channels: [slack]
    message: "Decision completion rate has dropped to {{ $value }}%"
    duration: "1h"
    
  - name: AgentConfusionSpike
    condition: increase(tactics_agent_confusion_incidents[1h]) > 5
    severity: p2
    channels: [slack]
    message: "Agent confusion incidents spiked: {{ $value }} in the last hour"
    
  - name: RebuildDurationHigh
    condition: tactics_rebuild_duration_seconds > 300
    severity: p3
    channels: [email]
    message: "Index rebuild took {{ $value }}s, exceeding 5 minute threshold"
```

---

# PART 10: CONTINUOUS IMPROVEMENT LOOP

## 10.1 Improvement Workflow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                CONTINUOUS IMPROVEMENT LOOP                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────┐                                                           │
│   │   DEPLOY    │◄──────────────────────────────────────────────┐          │
│   │   DECISION  │                                               │          │
│   └──────┬──────┘                                               │          │
│          │                                                      │          │
│          ▼                                                      │          │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐      │          │
│   │   COLLECT   │────►│   ANALYZE   │────►│   IDENTIFY  │      │          │
│   │   METRICS   │     │   TRENDS    │     │   GAPS      │      │          │
│   └─────────────┘     └─────────────┘     └──────┬──────┘      │          │
│                                                  │              │          │
│   METRICS:                                       ▼              │          │
│   • Decision velocity                            ┌─────────────┐│          │
│   • Approval ratings                             │  DECISION   ││          │
│   • Agent confusion                              │  REQUIRED?  ││          │
│   • System health                                └──────┬──────┘│          │
│                                                         │       │          │
│   THRESHOLDS:                              ┌──────────┴────┐   │          │
│   • Approval < 85% → Trigger               │               │   │          │
│   • Confusion > 5/day → Trigger            ▼               ▼   │          │
│   • Error rate > 10% → Trigger      ┌─────────┐     ┌─────────┐│          │
│   • Velocity drop > 20% → Trigger   │   NO    │     │   YES   ││          │
│                                     └────┬────┘     └────┬────┘│          │
│                                          │               │     │          │
│                                          ▼               ▼     │          │
│                                   ┌──────────┐    ┌──────────┐│          │
│                                   │ Continue │    │ Create   ││          │
│                                   │ Monitoring    │ IMP-XXX  ││          │
│                                   └──────────┘    └────┬─────┘│          │
│                                                        │      │          │
│   ┌─────────────┐                                      ▼      │          │
│   │   CLOSE     │◄─────────────────────────────┐  ┌──────────┐│          │
│   │   DECISION  │                              │  │ IMPROVE  ││          │
│   └─────────────┘                              └──┤  DECISION│◄┘          │
│                                                   └──────────┘            │
│                                                                             │
│   IMPROVEMENT DECISION TEMPLATE:                                            │
│   • Trigger condition (what metric/value)                                   │
│   • Success criteria (how we know it's better)                              │
│   • A/B comparison approach (measure against baseline)                      │
│   • Rollback criteria (when to revert)                                      │
│   • Review schedule (when to evaluate)                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 10.2 Improvement Decision Template

```markdown
# IMPROVEMENT DECISION TEMPLATE

## Header
```yaml
---
ImprovementId: IMP-[NUMBER]
Title: [Clear improvement description]
Status: proposed
ParentDecision: [Original decision ID]
TriggerCondition: [What metric/value triggered this]
Priority: high/medium/low
Author: [Name]
Created: YYYY-MM-DDTHH:MM:SS
---
```

## 1. TRIGGER ANALYSIS
**Triggered By:** [Specific metric or observation]

**Current State:**
- Metric: [Name and value]
- Threshold: [What value should trigger action]
- Duration: [How long has this condition persisted]

**Impact:**
- [ ] Blocks workflow
- [ ] Degrades performance
- [ ] Increases errors
- [ ] Reduces clarity

## 2. ROOT CAUSE
[Analysis of why the current state is suboptimal]

## 3. PROPOSED IMPROVEMENT
### Option A: [Description]
**Expected Improvement:**
**Effort:**
**Risk:**

### Option B: [Description]
[Same structure]

## 4. SUCCESS METRICS
| Metric | Current | Target | Measurement |
|--------|---------|--------|-------------|
| [Name] | [Value] | [Value] | [Method] |

## 5. A/B TESTING PLAN
**Control Group:** [What stays the same]
**Treatment Group:** [What changes]
**Duration:** [How long to run test]
**Sample Size:** [Minimum for statistical significance]

## 6. ROLLOBACK CRITERIA
Rollback immediately if:
- [ ] Metric degrades by > X%
- [ ] New errors introduced
- [ ] Agent complaints increase
- [ ] [Other conditions]

## 7. IMPLEMENTATION
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

## 8. REVIEW SCHEDULE
- **Initial Review:** [1 week after deployment]
- **Final Review:** [4 weeks after deployment]
- **Decision:** Adopt / Revert / Iterate

## 9. APPROVAL
| Role | Name | Decision | Date |
|------|------|----------|------|
| Strategist | | Adopt/Modify/Reject | |
| Oracle | | Rating | |
```

## 10.3 Auto-Approval Rules

```powershell
# Improvement-AutoApproval.ps1
function Test-ImprovementAutoApproval {
    param([hashtable]$Improvement)
    
    # Rule 1: Low risk + small scope = auto-approve
    if ($Improvement.Risk -eq "low" -and 
        $Improvement.Scope -eq "single-file" -and
        $Improvement.EstimatedHours -lt 2) {
        return @{ AutoApprove = $true; Reason = "Low risk, small scope" }
    }
    
    # Rule 2: Documentation only = auto-approve
    if ($Improvement.Category -eq "documentation" -and
        $Improvement.FilesAffected -notmatch "\.(ps1|cs|js|py)$") {
        return @{ AutoApprove = $true; Reason = "Documentation only" }
    }
    
    # Rule 3: Test additions = auto-approve
    if ($Improvement.Category -eq "testing" -and
        $Improvement.TestCoverageIncrease -gt 0) {
        return @{ AutoApprove = $true; Reason = "Improves test coverage" }
    }
    
    # Rule 4: Bug fix with regression test = auto-approve
    if ($Improvement.Type -eq "bugfix" -and
        $Improvement.HasRegressionTest -eq $true) {
        return @{ AutoApprove = $true; Reason = "Bug fix with regression test" }
    }
    
    # Rule 5: Metric-driven improvement below threshold
    if ($Improvement.TriggerCondition -and
        $Improvement.EstimatedImpact -lt 10 -and  # < 10% change expected
        $Improvement.CanRollback -eq $true) {
        return @{ AutoApprove = $true; Reason = "Low-impact metric improvement with rollback" }
    }
    
    return @{ AutoApprove = $false; Reason = "Requires manual review" }
}
```

## 10.4 Decision Fatigue Prevention

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              DECISION BATCHING STRATEGY                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  DAILY:                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Auto-approve improvements (via rules)                             │   │
│  │ • Review agent confusion incidents                                  │   │
│  │ • Check critical alerts                                             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  WEEKLY:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Review all pending decisions                                      │   │
│  │ • Analyze metrics trends                                            │   │
│  │ • Batch related improvements                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  MONTHLY:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Strategic review of decision patterns                             │   │
│  │ • Template improvements                                             │   │
│  │ • Process refinements                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  QUARTERLY:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ • Architecture roadmap review                                       │   │
│  │ • Major framework decisions                                         │   │
│  │ • Tooling evaluations                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  BATCHING RULES:                                                            │
│  • ≤3 related IMP decisions → Single TECH decision                        │
│  • ≤3 related TECH decisions → Single FORGE decision                      │
│  • Similar improvements → Grouped implementation batch                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

# PART 11: IMPLEMENTATION ROADMAP

## 11.1 Phase 1: Foundation (Week 1-2)
- [ ] Implement index rebuild system
- [ ] Create validation pipeline (warning mode)
- [ ] Set up basic monitoring
- [ ] Deploy to pilot user

## 11.2 Phase 2: Core Systems (Week 3-4)
- [ ] Deploy ID allocation system
- [ ] Implement path resolution
- [ ] Enhanced templates
- [ ] Deploy to team leads

## 11.3 Phase 3: Hardening (Week 5-6)
- [ ] Enable strict validation
- [ ] Complete test coverage
- [ ] Rollback procedures
- [ ] Full team deployment

## 11.4 Phase 4: Optimization (Week 7-8)
- [ ] Granular decision workflow
- [ ] Continuous improvement loop
- [ ] Performance optimization
- [ ] Documentation completion

---

# APPENDIX: QUICK REFERENCE

## A. Command Cheat Sheet

```powershell
# Index Management
.\T4CT1CS\scripts\Rebuild-TacticsIndex.ps1                    # Full rebuild
.\T4CT1CS\scripts\Rebuild-TacticsIndex.ps1 -DryRun            # Preview
.\T4CT1CS\scripts\Rebuild-TacticsIndex.ps1 -Force             # Force rebuild

# ID Management
Import-Module .\T4CT1CS\scripts\TacticsIdAllocator.psm1
New-TacticsId -Prefix "TECH" -Count 5                          # Allocate IDs
Get-TacticsIdStatus "TECH-47"                                  # Check status
Confirm-TacticsIdReservation -Id "TECH-47"                     # Claim reserved

# Path Resolution
Import-Module .\T4CT1CS\scripts\TacticsPathResolver.psm1
Resolve-TacticsPath "decisions/active/FORGE-001.md"            # Resolve path
Register-PathMove -From "old" -To "new" -DecisionId "FORGE-001"

# Validation
Import-Module .\T4CT1CS\scripts\TacticsValidator.psm1
Invoke-TacticsValidation                                       # Run all checks
Test-TacticsFile "path/to/file.md" -Mode "strict"              # Single file

# Testing
Invoke-Pester -Path "T4CT1CS/Tests"                            # Run tests
```

## B. Environment Variables

```powershell
$TACTICS_VALIDATION_MODE = "warning"   # migration|warning|soft|strict
$TACTICS_AUTO_REBUILD = "true"         # true|false
$TACTICS_LOG_LEVEL = "info"            # debug|info|warn|error
$TACTICS_ROOT = "C:\P4NTH30N\T4CT1CS"  # Override root path
```

## C. File Locations

```
T4CT1CS/
├── .index/
│   ├── tactics-index.json          # Master index
│   ├── decisions.json              # Decision catalog
│   ├── consultations.json          # Consultation catalog
│   ├── actions.json                # Action catalog
│   ├── references.json             # Cross-reference map
│   ├── aliases.json                # Path alias registry
│   ├── health.json                 # System health
│   ├── errors.json                 # Validation errors
│   ├── id-registry.json            # ID allocation state
│   ├── validation-rules.json       # Validation configuration
│   ├── .checkpoints/               # Rebuild checkpoints
│   └── .backups/                   # Index backups
├── decisions/
│   ├── active/                     # Active decisions
│   └── archive/                    # Historical decisions
├── consultations/
│   ├── designer/                   # Designer consultations
│   ├── oracle/                     # Oracle consultations
│   └── strategist/                 # Strategist consultations
├── actions/
│   ├── backlog/                    # Pending actions
│   ├── active/                     # In-progress actions
│   └── completed/                  # Completed actions
└── scripts/
    ├── Rebuild-TacticsIndex.ps1    # Index rebuild
    ├── TacticsIdAllocator.psm1     # ID allocation
    ├── TacticsPathResolver.psm1    # Path resolution
    ├── TacticsValidator.psm1       # Validation engine
    └── DecisionRouter.ps1          # Decision routing
```

---

**Designer Sign-off:**

This comprehensive design addresses all Oracle concerns and provides robust, fail-safe systems for the FORGE-001 Directory Architecture standardization.

Key accomplishments:
- ✅ **Automated Index Rebuild**: Idempotent, checkpointed, recoverable
- ✅ **ID Sequencing Control**: Atomic allocation with reservation system
- ✅ **Staged Validation**: Warning → Soft → Hard progression
- ✅ **Path Alias System**: Redirect registry with validation
- ✅ **Granular Decisions**: 4-level hierarchy with auto-routing
- ✅ **Enhanced Templates**: Complete specification with level-appropriate requirements
- ✅ **Testing Strategy**: Full pyramid from unit to E2E
- ✅ **Deployment Plan**: Phased rollout with clear gates and rollback
- ✅ **Monitoring**: Comprehensive metrics, alerts, and dashboards
- ✅ **Continuous Improvement**: Automated loop with fatigue prevention

**Target Oracle Approval: 95%+**

— Aegis, Designer

